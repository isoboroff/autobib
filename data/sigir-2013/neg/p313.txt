Improve Collaborative Filtering
Through Bordered Block Diagonal Form Matrices
Yongfeng Zhang, Min Zhang, Yiqun Liu, Shaoping Ma
State Key Laboratory of Intelligent Technology and Systems
Tsinghua National Laboratory for Information Science and Technology
Department of Computer Science & Technology, Tsinghua University, Beijing, 100084, China

zhangyf07@gmail.com {z-m,yiqunliu,msp}@tsinghua.edu.cn
ABSTRACT
Collaborative Filtering-based recommendation algorithms have
achieved widespread success on the Web, but little work has
been performed to investigate appropriate user-item relationship structures of rating matrices. This paper presents
a novel and general collaborative filtering framework based
on (Approximate) Bordered Block Diagonal Form structure
of user-item rating matrices. We show formally that matrices in (A)BBDF structures correspond to community detection on the corresponding bipartite graphs, and they reveal
relationships among users and items intuitionally in recommendation tasks. By this framework, general and special
interests of a user are distinguished, which helps to improve
prediction accuracy in collaborative filtering tasks. Experimental results on four real-world datasets, including the
Yahoo! Music dataset, which is currently the largest, show
that the proposed framework helps many traditional collaborative filtering algorithms, such as User-based, Item-based,
SVD and NMF approaches, to make more accurate rating
predictions. Moreover, by leveraging smaller and denser submatrices to make predictions, this framework contributes to
the scalability of recommender systems.

Categories and Subject Descriptors
H.3.3 [Information Storage and Retrieval]: Information
Filtering; H.3.5 [Online Information Services]: Webbased services

Keywords
Collaborative Filtering; Community Detection; Block Diagonal Form; Graph Partitioning

1.

INTRODUCTION

Recommender Systems play an important role on the Web
which is becoming more and more personalized. With their
ability to discover various items of potential interest to users,
recommender systems benefit users by saving time when the

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
SIGIR’13, July 28–August 1, 2013, Dublin, Ireland.
Copyright 2013 ACM 978-1-4503-2034-4/13/07 ...$15.00.

313

users are looking for what they want, and they benefit online
shops that seek to expand their marketing efforts.
Collaborative Filtering (CF) [22] recommendation algorithms based on user-item rating matrices have achieved
great success in recommender systems. Typically, they take
a rating matrix (Figure 1(a)) as input to make rating predictions, where each row/column/cross represents a user/item/
rating. An important advantage of CF-based algorithms is
their ability to make recommendations without clear content descriptions of the items, which is the reason why they
are widely applied in recommender systems thus far [22].
However, CF-based recommendation algorithms also suffer from several drawbacks. First is the data sparsity problem, which usually decreases the accuracy of the rating predictions. Second is the problem of scalability, which is usually caused by the presence of computationally expensive
training components. Finally, the lack of distinguishing
users and items from different communities, which makes
them incapable of detecting users’ special interests and decreases their abilities to make long tail recommendations.
Some previous research has been performed attempting
to address these problems, which mainly focus on various
matrix-clustering [11, 26, 27, 39, 34] or community detection
[6, 36, 23] techniques. Clustering-based approaches cluster
users and/or items for CF. However, in real-world applications, clusters are usually difficult to interpret. Moreover,
they usually assume that a user or an item should fall into
one particular cluster, which might not be a reasonable assumption in reality. Community detection approaches based
on user-item bipartite graphs attempt to improve accuracy
and diversity by detecting user-item communities. Distinguishing the general and special interests of a given user
helps to make better recommendations, but it is difficult for
them to take advantage of various successful CF techniques
on rating matrices in real-world recommender systems.
In fact, rating matrices and bipartite graphs can be equivalently transformed into each other. Before problem formalization, we would like to use an intuitional example to
introduce the matrix structures that are leveraged in this
framework. Figure 1(a) shows a rating matrix, and its corresponding bipartite graph is shown in Figure 1(d), where each
row/column/non-zero of the matrix is represented as an Rnode/C-node/Edge in the graph. Figure 1(b) is a Bordered
Block Diagonal Form (BBDF) structure of the original matrix, where Row4, Row9 and Column7 are permuted to ‘borders’, and the remaining parts are thus permuted into two
‘diagonal blocks’. The permuting procedure is conducted
recursively on the first diagonal block. The Approximate











 









 








  





 



(a) Original Matrix









(d) Original Graph





 







 





















(e) BBDF Graph





































 

(c) ABBDF matrix




 
 























(b) BBDF matrix















 





   













 



 

  









 



 



 





(f) ABBDF Graph

Figure 1: An example of User-Item Rating Matrices and their corresponding Bipartite Graphs.
theorems. Section 4 presents the proposed algorithms and
framework. Experimental settings and results are shown in
section 5. In section 6, we present a discussion, and section
7 concludes the work and provides future directions.

Bordered Block Diagonal Form (ABBDF) structure is a generalization of BBDF where scattered non-zeros are allowed
in off-diagonal blank areas, as shown in Figure 1(c).
It is important to note that the ABBDF structure of rating matrices is capable of representing community detection
results on the corresponding bipartite graphs. In Figure
1(f), for example, each community in the graph corresponds
to a diagonal block in Figure 1(c); nodes out of communities constitute borders, and dotted inter-community edges
correspond to the non-zeros in off-diagonal blank areas. In
this sense, BBDF structure is a special case of ABBDF when
the community detection result contains no inter-community
edge, as shown by the example in Figure 1(e) and 1(b).
The CF framework based on (A)BBDF structures of rating matrices proposed in this paper is capable of combining
the advantages of community detection and matrix clustering techniques as well as making use of various CF algorithms. An important advantage of this framework is that
it does not rely on a specific CF algorithm. Any CF algorithm that is based on rating matrices can be integrated into
this framework, such as User-based, Item-based, SVD and
NMF. Experimental results show that this framework helps
these CF algorithms to improve the prediction accuracy and,
at the same time, benefits system scalability.
In summary, the contributions of the paper are four-fold:

2.

RELATED WORK

Collaborative Filtering (CF) [22, 2] algorithms based on
user-item rating matrices focus on the core task of making
rating predictions. They attempt to discover and leverage
the knowledge of users’ preferences when making recommendations. Unlike Content-Based Filtering (CBF) [28], which
makes recommendations by analyzing the item features of a
user’s historical items, CF algorithms take advantage of the
wisdom of crowds, and they usually have no special requirements on items or domains.
One of the most widely used forms of CF is the nearest
neighbor approach [22]. User-based [29] and Item-based [31]
CF algorithms are two best-known methods that fall into
this category. Nearest neighbors can be determined by various similarity measures, such as Pearson correlation and
cosine similarity. User-based CF attempts to find the neighborhood of like-minded users for each user and predicts a
user’s ratings according to the ratings given by the user’s
neighbors. Similarly, Item-based CF takes advantage of the
similar items of each item, and predictions for a user are determined by the user’s historical ratings. Nearest neighbor
approaches are usually unable to detect item synonymies
and are also computationally expensive in real-world recommender systems.
The Matrix Factorization (MF) [16] approaches attempt
to factorize a rating matrix into products of real-valued component matrices. A reconstruction error objective function
is usually defined, and gradient descent optimization procedures are usually conducted [25]. SVD [33, 37] and NMF [17,
40, 19] methods are typical algorithms that are investigated.
However, computationally intensive training components of
these techniques make them not scalable enough and impractical to conduct frequent model re-training. Incremental and
distributed versions of SVD and NMF algorithms [4, 37, 32,
21, 10] partially alleviate this problem, but they are still not

• The relationship between (A)BBDF structures of rating matrices and community detection on the corresponding bipartite graphs is investigated formally.
• Two density-based algorithms are designed to transform sparse rating matrices into (A)BBDF structures.
• We propose a general collaborative filtering framework
based on these structures to make rating predictions
in recommendation tasks.
• Both the efficiency and effectiveness of the proposed
framework are verified through experimental studies
on four benchmark datasets.
In the remaining part of this paper, section 2 reviews some
related work, and section 3 introduces some definitions and

314

efficient enough because the effects of small updates to the
rating matrix are not localized.
Various matrix clustering techniques have been investigated in an attempt to address the problems of efficiency,
scalability and sparsity. User clustering and item clustering
methods [26] cluster user or item vectors first, and nearest
neighbors of a user or item are restricted to its cluster. Some
other matrix clustering techniques, such as co-clustering [7,
18, 11], ping-pang algorithm [27] and clustered low-rank approximation [35], cluster users and items at the same time,
and the procedure of rating prediction takes advantage of
these user-item clusters. By utilizing clusters, the scalability of recommender systems is usually improved, but clusters are usually difficult to interpret. In addition, these
approaches usually force a user or item to fall into a single cluster, which might not be a reasonable assumption in
real-world applications.
Recently, community detection techniques based on graphs
have been investigated extensively with the rapid growth of
social networks [20, 24, 23, 6], which helps to improve both
the accuracy and diversity of the recommender systems by
extracting user or item communities.
In fact, user-item rating matrices can be equivalently transformed into bipartite graphs [1, 3], and community detection results on the bipartite graphs can be represented as
(A)BBDF structures on the corresponding rating matrices.
Any CF method can still be applied to the permuted matrix without any modification, but by leveraging user-item
community information therein, more accurate and specific
recommendations can be made.

3.

(a) Communities

(b) Middle result

(c) ABBDF

Figure 2: Community detection and ABBDF, k = 2
Namely, Aij (i != j, 1 ≤ i, j ≤ k) can also contain scattered
non-zeros compared with the BBDF structure. D1 D2 · · · Dk
might also be in the ABBDF structure. !
ABBDF is a generalization of BBDF in that scattered
non-zeros are allowed in off-diagonal blank areas. We also
refer to BBDF as Accurate BBDF to distinguish it from
Approximate BBDF.
Definition 3. Community Detection. Given a graph
G = (V, E), a community in G is a set of vertices Ci ⊆ V,
and a community detection with k (k ≥ 1) communities is
C = {C1 C2 · · · Ck }, witch satisfies the following:
i. Ci != ∅ (1 ≤ i ≤ k)
#
! "
k
ii. Ci ∩
Cj != Ci (1 ≤ i ≤ k)
j=1,j!=i

The second requirement means that each community contains at least one monopolized node. It’s important to clarify
that no definition of community detection is universally accepted until now because definitions often depend on a specific application and algorithm [9]. This definition is solely
for introducing the relationships between the (A)BBDF structure and community detection in this paper. Even so, Definition 3 is general enough to describe the output of many
frequently used community detection algorithms, including
both independent
and
% overlapping communities, depending
$ "k
on Ci ∩
j=1,j!=i Cj = ∅ (1 ≤ i ≤ k) or not.

DEFINITIONS AND THEOREMS

Several definitions and theorems are presented in this section, which will be the basis of the (A)BBDF permutation
algorithms and the collaborative filtering framework to be
proposed in Section 4.

Theorem 1. Any community detection result with k comDefinition 1. Bordered Block Diagonal Form (BBDF).
munities C = {C1 C2 · · · Ck } on a bipartite graph G = (V, E)
Matrix A is in Bordered Block Diagonal Form if:
can be represented as an ABBDF structure with k diagonal
 


C1
A11 A12 · · · A1k A1B
D1
blocks on its corresponding rating matrix A.
 A21 A22 · · · A2k A2B  
D2
C2 
"
 


Proof. Without loss of generality, we assume that ki=1 Ci =

.. . .
..
..  = 
..  (1)
..
A =  ..



.
.
.
.
.  
. 
 .
V, in other words, that each node belongs to at least
" one
 
A
D k Ck 
k1 Ak2 · · · Akk AkB
community. Otherwise, we permute the nodes in V − ki=1 Ci
AB1 AB2 · · · ABk ABB
R1 R2 · · · R k B
to the borders first. We will make a proof by induction.
If k = 1, then the property holds naturally, and the matrix
Namely, Aij = 0 (i != j, 1 ≤ i, j ≤ k). Each Di (1 ≤
is viewed as a single diagonal block.
i ≤ k) is a ‘diagonal block’; R = [R1 · · · Rk B] and C =
If k = 2, then permute the nodes in S = C1 ∩C2 to borders,
[C1T · · · CkT B T ]T are ‘borders’. Recursively, each of the diagfollowed
by permuting the nodes in C1" = C1 − S and C2" =
onal blocks Di can also be in the BBDF structure. !
C2 − S to construct two diagonal blocks, shown in Figure 2.
Suppose that the property holds for k = $n"− 1. When
BBDF structure is a generalization of Block Diagonal Form
%
n
k = n, as shown in Figure 3, let S1 = C1 ∩
(BDF) matrices, for example, A = diag(D1 D2 · · · Dk ), where
i=2 Ci and
"
"
Ci = Ci − S1 (1 ≤ i ≤ n). Note that Ci != ∅ (1 ≤ i ≤ n),
the latter has no border.
Definition 2. Approximate Bordered Block Diagonal Form (ABBDF). Matrix A is in Approximate Bordered Block Diagonal Form if:


A11
 A21


A =  ..
 .
A
k1
AB1

A12
A22
..
.
Ak2
AB2

···
···
..
.
···
···

A1k
A2k
..
.
Akk
ABk

 
A1B
D1
A2B   A21
 
..  =  ..

. 
  .
AkB   Ak1
ABB
R1

A12
D2
..
.
Ak2
R2

···
···
..
.
···
···

A1k
A2k
..
.
Dk
Rk


C1
C2 

..  (2)
. 

Ck 
B

Figure 3: Community detection and ABBDF, k = n

315




according to Definition 3. Permute the vertices in S1 to the
borders,
permute C1" to the upper-left corner and permute
"n
"
corner. According to the induci=2 Ci to the bottom-right
"
"
tive assumption, n
i=2 Ci can be permuted into an ABBDF
structure with n − 1 diagonal blocks in the same manner.
As a result, the final matrix is an ABBDF structure
with n
"
diagonal blocks, and the final border is S = n−1
i=1 Si .






  
























 

(a) A block in matrix











 



 








  







 



 






















 

(b) Restricted lines

Figure 5: Block, Line and Line Density

It is helpful to look at the case of k = 3, as shown in Figure
4. First, let S1 = C1 ∩ (C2 ∪ C3 ) and Ci" = Ci − S1 (i = 1, 2, 3).
Permute S1 to the borders, and there will be two diagonal
blocks in the matrix, corresponding to vertex sets C1" and
C2" ∪ C3" . Moreover, let S2 = C2" ∩ C3" and Ci"" = Ci" − S2 (i =
2, 3). By recursively permuting S2 to the borders, one of the
diagonal blocks is again permuted into an ABBDF structure,
which gives us two new diagonal blocks that correspond to
C2"" and C3"" . The final number of diagonal blocks is 3, and
the border is S = S1 ∪ S2 .

Adj(Vi ) ⊂ VS for 1 ≤ i ≤ k, Vi ∩ Vj = ∅ for 1 ≤ i < j ≤ k,
"
and ( ki=1 Vi ) ∪ VS = V. Note that VS = ∅ is allowed.
C = {C1 C2 · · · Ck } is the community detection result, where
Ci = Vi ∪ VS (1 ≤ i ≤ k). !
Intuitively in GPVS, the removal of a vertex separator
splits the graph into k connected components. GPVS is a
type of community detection algorithm that corresponds to
accurate BBDF structures. This conclusion can be derived
directly
from%Corollary 1 and Definition 4 because Si = Ci ∩
$ "k
"
j=1,j!=i Cj = VS and Ci = Ci − Si = Vi are disconnected
when i != j.
The reader can refer to Figure 1(b) and 1(e) for an example. By first removing nodes R4 R9 and C7 which are
represented by shaded borders, the remaining nodes are partitioned into two parts, corresponding to the two main diagonal blocks in the rating matrix. Furthermore, by removing
nodes R3 C2 and C9 , one of the diagonal blocks is again permuted into the BBDF structure with two diagonal blocks.

Corollary 1. Given a community detection
$ "kresult C =%
{C1 C2 · · · Ck } on a bipartite graph, let Si = Ci ∩
j=1,j!=i Cj
and Ci" = Ci − Si for each 1 ≤ i ≤ k. Then, C corresponds to
an Accurate BBDF structure if and only if there is no edge
from Ci" to Cj" when i != j.
Proof. The result follows from the fact that a non-zero
in the off-diagonal blank areas in an ABBDF structure corresponds to an edge that connects two nodes, u and v, from
two communities, C(u) and C(v), where u and v are monopolized by C(u) and C(v), correspondingly.

Definition 5. Graph Partitioning by Edge Separator (GPES)-based Community Detection.
Consider the undirected graph G = (V, E).
ES ⊂ E is an edge separator if the removal of ES gives
Γe = {V1 V2 · · · Vk } (k ≥ 2), where Vi != ∅ for 1 ≤ i ≤ k,
"
Vi ∩ Vj = ∅ for 1 ≤ i < j ≤ k, ki=1 Vi = V, and the
subgraphs induced by Vi and Vj are disconnected for i != j.
C = {C1 C2 · · · Ck } is the community detection result, where
Ci = Vi (1 ≤ i ≤ k). !

Intuitionally, a diagonal block in an (A)BBDF matrix is
a ‘user-item community’, with its users and items being its
‘dominant’ users and items. The borders can be viewed as
‘super’ users and items among communities. Super users are
users whose tastes are relatively broad and fall into different
communities. Super items are items favored by users from
different communities. Users might indeed focus their main
attentions on certain fields, but they do step into other fields
occasionally, which is important when detecting the potential interests of a user. In this sense, an Approximate BBDF
structure is more natural than an Accurate BBDF structure.
The following definitions and theorems concern how to
permute a sparse rating matrix into accurate and approximate BBDF structures.

GPES-based community detection corresponds
%
$ "k to an ABBDF
structure with no border because Si = Ci ∩
j=1,j!=i Cj =
∅. This structure can be used to further construct an ABBDF
structure with borders when necessary, which will be presented by the algorithms in the following sections.
Definition 6. Density. Let A be an m × n (m, n ≥ 1)
matrix, let n(A) be the number of non-zeros in A, and let
area(A) = m × n be the area of A.
n(A)
The density of A is ρ(A) = area(A)
, and the average den-

Definition 4. Graph Partitioning by Vertex Separator (GPVS)-based Community Detection.
Consider an undirected graph G = (V, E). Adj(v) denotes
the set of vertices adjacent to v. For a vertex subset V " ⊂ V,
Adj(V " ) = {vj ∈ V − V" : ∃vi ∈ V " s.t. vj ∈ Adj(vi )}.
VS ⊂ V is a vertex separator if the subgraph induced by
V − VS has k ≥ 2 connected components. Formally, GPVS is
defined as Γv = {V1 V2 · · · Vk ; VS }, where Vi != ∅, Vi ∩VS = ∅,

sity of k matrices A1 · · · Ak is ρ̄(A1 · · · Ak ) =

!k
n(Ai )
!k i=1
.
i=1 area(Ai )

Let G denote the bipartite graph of A; then, ρ(G) = ρ(A),
ρ̄(G1 · · · Gk ) = ρ̄(A1 · · · Ak ).
A row or a column of matrix A is referred to as a ‘line’.
The density of line l restricted to a block B is ρ(l(B)), where
l(B) denotes the sub-vector on line l that is restricted to block
B, shown as the red dashed rectangles in Figure 5(b). !
The density of graphs or matrices has been widely used
in various community detection algorithms and tasks [9].
Taking Figure 5 as an example, the density of the shaded
9
block is 25
in Figure 5(a). In Figure 5(b), the density of
column 5 is 59 , and the density of row 8 restricted to the
shaded block is 25 .

Figure 4: Community detection and ABBDF, k = 3

316

4.

ALGORITHMS

4.1
4.1.1

where ρ2 represents the average density of off-diagonal
blank areas plus borders. Let ρ̄(D1 · · · Dk ) > ρ(A), namely,
ρ1 > ρA ; then, we have:

Accurate BBDF Permutation

n1
n
n1 + n2
> =
s1
s
s1 + s2

Basic Procedure of BBDF Permutation

In accurate BBDF permutation, a basic procedure is performed recursively, which is to permute some lines to borders
and to permute the remaining part to construct several diagonal blocks. This recursive framework is known as George’s
nested dissection approach [3, 14], which has been widely
used in fill-reducing ordering of sparse matrices. This basic
procedure is investigated in this subsection, and the accurate BBDF permutation algorithm in the following subsection leverages this procedure.
The basic step is equivalent to GPVS [1] on the corresponding user-item bipartite graph, which has been shown
in preliminaries. It is typical that a graph has more than one
vertex separator, and a proper GPVS algorithm attempts
to find the one with the least number of vertices, namely,
the minimum vertex separator. Unfortunately, the minimum
vertex cut problem is known to be NP-hard [5], but this
problem has been investigated extensively, and many efficient and high-quality heuristic-based methods have been
proposed [15], such as the multilevel approach, spectral partitioning and kernel-based methods. It has been verified
both theoretically and experimentally that multilevel approaches usually provides both fast execution time and very
high quality partitions [15, 30, 1, 3]. Perhaps the most
widely known and used package for graph partitioning is
Metis by Karypis [13], which is based on a multilevel approach, and we chose the core multilevel graph partitioning
routine implemented in Metis as the basic GPVS algorithm.
In this study, we utilize the density of user-item communities to control the procedure of BBDF permutation because
dense subgraphs are usually interpreted as actual communities. This approach has been widely used in community
detection tasks [9]. Algorithm 1 shows the basic procedure.

⇔

n1
n2
>
s1
s2

⇔ ρ1 > ρ2

This statement means that the average density of the resulting diagonal blocks will increase if and only if it is greater
than the average density of the remaining parts. This relationship is usually satisfied because the GPVS algorithm
attempts to find a separator with the minimum number of
vertices. Furthermore, the total area of off-diagonal blocks
plus borders tends to be much larger than the area of the
diagonal blocks [1]. For this reason, we choose the average
density to be an important controller in the algorithm.

4.1.2

Accurate BBDF Permutation Algorithm

The density-based BBDF permutation algorithm requires
a parameter ρ as an input, which is a pre-defined requirement on the minimum average density of diagonal blocks.
It conducts Basic-BBDF-Permutation on a matrix and recurses on each of the resulting diagonal blocks until the density of a diagonal block has reached the density requirement
ρ or the Basic-BBDF-Permutation cannot improve the average density any more. Algorithm 2 shows the procedure.
Algorithm 2 BBDF-Permutation(A, G, ρ)
Require:
User-Item rating matrix A.
Bipartite graph G = (V, E) of A.
Density requirement ρ.
Ensure:
Matrix A permuted into BBDF structure.
1: ρA ← ρ(A)
2: if ρA < ρ then
! else do nothing
3:
ρ̄ ← Basic-BBDF-Permutation(A, G)
4:
if ρ̄ > ρA then
! else do nothing
5:
for each diagonal block Di in A do
6:
BBDF-Permutation(Di , GVi , ρ) ! Vi denotes
the vertex set of Di , GVi is the subgraph induced by Vi
7:
end for
8:
end if
9: end if

Algorithm 1 Basic-BBDF-Permutation(A, G)
Require:
User-Item rating matrix A.
Bipartite graph G = (V, E) = (R ∪ C, E) of A. ! R/C
are row/column vertex sets of V correspondingly.
Ensure:
Average density of resulting diagonal blocks ρ̄.
1:Γ v ← {V1 V2 · · · Vk ; VS } ← GPVS(G)
2: Permute rows of A in order of R1 R2 · · · Rk RS
3: Permute columns of A in order of C1 C2 · · · Ck CS
4: return ρ̄(D1 D2 · · · Dk ) ! Di denotes the i-th diagonal
block which corresponds to vertex set Vi = Ri ∪ Ci

Note that, in the 4-th line, we do nothing if the average density of the resulting diagonal blocks is not improved
compared with the original matrix, although some diagonals
might not have reached the density requirement ρ. Such a
diagonal D is viewed as a sparse user-item community, and
such a case occurs when the density requirement ρ is set
too high. An important reason for using the average density
to prevent such diagonals from recursion is that they would
result in many small scattered communities with only a few
users and items. Proper density requirements give better
BBDF structures, and this issue will be discussed with the
experimentation below.

We expect the average density of diagonal blocks to be
improved compared with the density of the original matrix
A after permutation; we discuss the relevant issues here.
Taking the notations in Definition 6, we have:
&k
n(Di )
n(A)
ρ(A) =
, ρ̄(D1 · · · Dk ) = &k i=1
area(A)
area(D
i)
i=1
&k
Let n = n(A), n1 = i=1 n(Di ), n2 = n−n1 ; s = area(A),
&
s1 = ki=1 area(Di ), s2 = s − s1 . We have:
n
n1
n2
, ρ2 =
ρA = ρ(A) = , ρ1 = ρ̄(D1 · · · Dk ) =
s
s1
s2

4.2

Approximate BBDF Permutation

Approximate BBDF can be achieved by GPES, and we
also make use of the multilevel graph partitioning approach
that is implemented in Metis. The ABBDF permutation
algorithm also has a density requirement of ρ, as input. It
computes a GPES on the bipartite graph of a rating matrix

317

A, and by ignoring the non-zeros corresponding to the edge
separator, matrix A is permuted to several diagonal blocks.
Unlike an accurate BBDF permutation, which accomplishes
nothing if the average density is not improved after the permutation, the approximate BBDF permutation algorithm
moves lines from diagonal blocks to borders to further improve their average density, unless the average density is
greater than the original matrix. Note that this goal can always be reached because the density of a single non-zero is
one. This procedure is performed recursively in each diagonal block until the density requirement is reached, as shown
in Algorithm 3.

Note that, when looking for the line that improves the
average density the most, there is no need to check all of
the lines in each diagonal block in a real implementation.
In each diagonal block, we only need to check the line with
the minimum density restricted to it, namely the line that
contains the fewest non-zeros in it.

4.3

Algorithm 3 ABBDF-Permutation(A, G, ρ)
Require:
User-Item rating matrix A.
Bipartite graph G = (V, E) = (R ∪ C, E) of A.
Density requirement ρ.
Ensure:
Matrix A permuted into ABBDF structure.
1: if ρ(A) ≥ ρ then
2:
return
3: else
4:Γ
e ← {V1 V2 · · · Vk } ← GPES(G)
5:
Permute rows of A in order of R1 R2 · · · Rk
6:
Permute columns of A in order of C1 C2 · · · Ck
7:
{V1" V2" · · · Vk" ; VS" } ←Improve-Density(A, G, Γe )
8:
for each diagonal block Di in A do
9:
ABBDF-Permutation(Di , GVi! , ρ)
10:
end for
11: end if
The sub-procedure Improve-Density selects the specific
line whose removal improves the average density the most
from the diagonal blocks at each time and inserts it into the
borders. This process is shown in Algorithm 4.



Algorithm 4 Improve-Density(A, G, Γe )
Require:
User-Item rating matrix A.
Bipartite graph G = (V, E) = (R ∪ C, E) of A.
GPES resultΓ e = {V1 V2 · · · Vk } of G.
Ensure:
Average density of diagonal blocks greater than ρ(A).
1: {V1" V2" · · · Vk" ; VS" } ← {V1 V2 · · · Vk ; ∅}
2: while ρ̄(D1 D2 · · · Dk ) < ρ(A) do
3:
l" , i" ← 0, ρ̄" ← 0
4:
for each diagonal block Di do
5:
for each !
line l in Di do
6:

7:
8:
9:
10:
11:
12:
13:
14:

ρ̄ ←

!k

k
j=1

(A)BBDF-based Rating Prediction

A great advantage of the CF framework based on the accurate or approximate BBDF structure is that any CF algorithm can be used on a submatrix that is made up of
diagonal blocks and borders. In this paper, we do not propose new CF algorithms on (A)BBDF structures but instead
propose a general CF framework, which makes use of useritem communities. By utilizing the community information,
the prediction accuracy tends to be improved. Furthermore,
conducting collaborative filtering on smaller and denser submatrices contributes to the scalability of CF algorithms.
The intuitive example shown in Figure 6 will be used to
introduce the framework. For each diagonal block, we reconstruct its corresponding community by combining it with
borders from different levels. Specifically, we use dominant
users and items together with the corresponding super users
and items to make predictions. In Figure 6, three submatrices are constructed, which correspond to the diagonal blocks
A, B and C. Note that, in the ABBDF structure, scattered
non-zeros in off-diagonal areas are ignored because they are
viewed as special interests or unprofessional ratings of users.
On each submatrix, any CF algorithm can be conducted
to make rating predictions. There could be more than one
prediction for user-item pairs from border crosses because
they are shared by different submatrices. These predictions
are averaged as the final prediction. It is a natural idea that
the predictions can be averaged with different weights, but
in this paper, we take only the average value. The averaging
strategy could be investigated in future work.



























(a) BBDF matrix



 






 
 



 



 
 







(b) Submatrices extracted

Figure 6: A toy example for extracting communities

5.
5.1

n(Dj )−n(l(Di ))

EXPERIMENTS
Dataset Description

We conducted a series of experiments on four real-world
datasets: MovieLens-100K, MovieLens-1M, Dianping and
Yahoo! Music to validate the effectiveness of the proposed
framework. Among these datasets, MovieLens-100K and
MovieLens-1M are from the well-known MovieLens dataset.

j=1 area(Dj )−area(l(Di ))
"

if ρ̄ > ρ̄ then
l" ← l, i" ← i, ρ̄" ← ρ̄
end if
end for
end for
Permute line l" to borders
Vi"! ← Vi"! − {node(l" )}
VS" ← VS" ∪ {node(l" )} ! node(l" ) denotes the node in
Vi"! corresponding to line l"
15: end while
16: return {V1" V2" · · · Vk" ; VS" }

Table 1: Statistics of the four datasets
#users
#items
#ratings
#ratings/user
#ratings/item
average density

318

ML-100K
ML-1M Dianping Yahoo! Music
943
6,040
11,857
1,000,990
1,682
3,952
22,365
624,961
100,000 1,000,209
510,551
262,810,175
106.045
165.598
43.059
262.550
59.453
253.089
22.828
420.523
0.0630
0.0419
0.00193
0.000421

Table 2: Community analysis for Approximate BBDF on Dianping when density requirement is 0.005
Community
City
#users
#restaurants
%accuracy

1
Chengdu
323
1189
89.6

(a) BBDF ρ = 0.005

2
Shenzhen
288
1359
90.4

3
Tianjin
922
2548
92.6

4
Beijing
2903
5011
94.4

5
Nanjing
684
1327
91.6

(b) BBDF ρ = 0.01

6
Suzhou
262
1443
88.7

7
Hangzhou
295
1309
89.2

8
Guangzhou
845
1274
90.7

(c) ABBDF ρ = 0.005

9
Shanghai
4531
4586
91.1

(d) ABBDF ρ = 0.01

Figure 7: Accurate BBDF (BBDF) and Approximate BBDF (ABBDF) structures on Dianping dataset

5.2

Algorithms and Evaluation Metrics

Four popular CF algorithms were experimented on using
the framework. The User-based and Item-based CF algorithms are famous memory based approaches, while SVD
and NMF are known to be famous matrix factorization approaches.
User-based: The Pearson correlation was used for user
similarities, as suggested in [29]. The neighborhood size is
k = 100.
Item-based: Adjusted cosine similarity was used because
it is reported to give the best performance in [31], and k =
100 is also used for neighborhood size.
SVD: We use the popular SVD prediction strategy presented in [16]. Here, the number of factors k is 100, and the
regularization coefficient λ is 0.015.
NMF: The most commonly used non-negative matrix factorization algorithm in [17] was used to make predictions,
and we also used k = 100 and λ = 0.015.
To make a comparison with the literature, we used the
Root Mean Square Error (RMSE) to measure the prediction accuracy in this work. Five-fold cross validation was
conducted on the MovieLens and Dianping datasets, and
the average RMSE was calculated. For the Yahoo! Music dataset, we used its training set and validation set for
training and evaluation, respectively.

319

25

Accurate BBDF
Approximate BBDF

20

MovieLens−100K

35
30

#Diagonal Blocks

#Diagonal Blocks

30

15
10
5

30
25

0.08

0.09

0.1

25
20

MovieLens−1M

15
10

Density Requirement

0
0.04

0.11

Accurate BBDF
Approximate BBDF

60

20
15

Dianping

10
5
0
0

Accurate BBDF
Approximate BBDF

5
0.07

#Diagonal Blocks

0
0.06

#Diagonal Blocks

Besides, we also collected a year’s data from a famous restaurant rating web site Dianping.com (http://www.dianping.com)
in China, and selected those users who made 20 or more ratings. The ratings also range from 1 to 5 like the MovieLens
dataset. The Yahoo Music dataset [8] is from KDD Cup
2011, and its ratings range from 1 to 100. Statistics on
these four datasets are presented in Table 1.
These datasets are chosen because they have different sizes
and densities. Additionally, two of them have more users
than items, and the other two are the opposite. We expect
to verify whether the framework works regardless of the size
or density of the matrix. A significant difference between
Dianping and other frequently used datasets is that Dianping is a location-based service in which the longitude and
latitude of each restaurant is recorded. By analyzing the
locations of user-item communities discovered by (A)BBDF
algorithms, we expect to obtain an intuitional observation
of their effects.

50

0.05

0.06

0.07

0.08

Density Requirement

0.09

Accurate BBDF
Approximate BBDF

40

Yahoo

30
20
10

0.01

0.02

0.03

0.04

Density Requirement

0.05

0

1

2

3

4

Density Requirement

5
−3

x 10

Figure 8: #communities v.s. density requirement

5.3

Community Analysis

The most important parameter in the density-based BBDF
and ABBDF permutation algorithms is the density requirement ρ. Low density requirements lead to fewer and larger
user-item communities, and high density requirements result in more and smaller communities, as shown in Figure
7, where ρ = 0.005 and ρ = 0.01 are applied to the accurate
and approximate BBDF algorithms on the Dianping dataset.
Note that the matrix is not as dense as it appears to be in
these figures; The appearance of density arises because more
than half a million points are restricted to a small canvas.
An appropriate density requirement is important. If the
density requirement is too low, then the user-item communities hidden in the original rating matrix cannot be extracted
properly and completely. However, if the density requirement is too high, then it will result in many small scattered
communities, which could lead to over-fitting problems.
An appropriate density requirement gives reasonable and
meaningful communities. See the ABBDF structure in Figure 7(d), for example. Nine communities are extracted,
numbered 1 through 9, from the upper-left to bottom-right
corner. It is interesting to note that they represent nine main
cities in China. Table 2 presents these cities and shows how
high a percentage of restaurants in each community truly
belong to that corresponding city.
One can find that communities 5, 6, 7 and 9 are highly related to each other by the dense pseudo-blank areas marked
by circles. By viewing the dense areas horizontally, we know

0.94

0.88

0.92

0.87

0.9

RMSE

0.91
0.9
0.89
0.88
0.06

0.86
0.85
0.84

User
Item
SVD
NMF

0.83
MovieLens−100K
0.07

0.08

0.09

Density Requirement

0.82
0.04

0.1

(a) acc.BBDF ML-100K

MovieLens−1M

0.05

0.06

0.07

MovieLens−100K

0.8
0

0.09

Density Requirement

Item

0.01

SVD

0.02

NMF

0.03

0.86

Item

0.07

0.08

SVD

NMF

0.09

0.1

0.11

(e) app.BBDF ML-100K

0.04

NMF

3

4

5
−3

x 10

Yahoo!
24
23
22

0.8
User

Density Requirement

SVD

2

Density Requirement

25

0.86

0.82
User

Item

1

(d) acc.BBDF Yahoo!

Dianping

0.88

0.82

0.88
0.06

User

26

0.84

0.84

0.89

21
0

0.05

0.92

RMSE

RMSE

0.04

Density Requirement

0.9

0.9

23
22

User

0.94
MovieLens−1M

0.88

0.91

24

(c) acc.BBDF Dianping

0.92

RMSE

0.86

0.82

0.08

0.9

0.93

Yahoo!

0.88

0.84

User
Item
SVD
NMF

(b) acc.BBDF ML-1M

0.94

25
Dianping

RMSE

RMSE

0.92

26

RMSE

0.89

0.93

RMSE

0.94

Item

0.05

SVD

0.06

NMF

0.07

0.08

Density Requirement

0.09

0.78
0

(f) app.BBDF ML-1M

User

Item

0.01

0.02

SVD

NMF

0.03

0.04

Density Requirement

0.05

(g) app.BBDF Dianping

21
0

User

Item

1

SVD

2

NMF

3

Density Requirement

4

5
−3

x 10

(h) app.BBDF Yahoo!

Figure 9: RMSE on the four datasets based on accurate (acc.) and approximate (app.) BBDF structures
the performance of all of the four CF algorithms on the corresponding dataset. Note that the beginning point of each
curve represents the base performance of the CF method on
the dataset, and the density requirement of this point is set
to the density of the whole rating matrix. As a result, points
on a curve below its beginning point mean an improvement
on the prediction accuracy, and vice versa.
We must note the fact that the very large number of users
and items in the Yahoo! Music dataset makes it unrealistic
for current hardware to conduct memory-based CF algorithms. To the best of our knowledge, there is no report
of direct user-based or item-based collaborative filtering on
this dataset. Strategies such as KNN with SVD features
[12] or parallelization [38] were attempted in KDD cup, but
these strategies would make the results incomparable with
other datasets. As a result, we did not perform KNN on the
whole dataset. However, we found that our CF framework
makes it possible to run KNN predictions on a standalone
machine when the number of communities is more than 27,
and experiments were performed in such cases.
Experimental results show that the proposed CF framework on accurate BBDF benefits user-based, SVD, and NMF
algorithms consistently on all of the four datasets. However,
mixed results were obtained on the item-based CF method.
On MovieLens-1M, Dianping and Yahoo! Music datasets,
its performance is slightly improved, but on the MovieLens100K dataset, its accuracy rises at first and begins to drop
while the density requirement continues to rise. Furthermore, a negative effect can even be introduced if the density
requirement is too high.
This effect could be the reason that the item-based algorithm utilizes historical ratings of a user, which is different
from other CF algorithms that take advantage of neighborhood relationships. A user’s historical ratings are reduced
in the BBDF framework, especially on small datasets, which
introduces bad predictions. However, it still benefits from
BBDF structure given reasonable density requirements.
For approximate BBDF structure, prediction accuracy improves at first but tends to drop when the density requirement is too high, in almost all of the cases. The reason for
the performance improvement could be that approximate
BBDF plays a role in data denoising, and user-item communities help to extract professional ratings. However, small

that users in one city can usually go to restaurants in another city, and vertically we know that restaurants in the
other city can be frequently visited by users from the first
city. These observations are reasonable in reality because
these four cities are geographically very close to each other,
as shown in Figure 10. Traffic among these cities is developed, and their business relationships are close. In fact, this
area is exactly the famous Yangtze River Delta of China.
Figure 8 shows the relationship between the number of
extracted communities and the density requirement on the
four datasets, respectively. For accurate BBDF, the number of communities rises first, and then tends to be stable
after a certain density requirement is met because a diagonal block will not be permuted recursively if its average
density does not increase after graph partitioning. However, for approximate BBDF, the number of communities
increases consistently because it moves lines to borders to
increase the average density in such cases. This strategy
makes the algorithm more flexible but could also lead to too
many small scattered communities if the density requirement is too high. The impact of the density requirement on
the prediction accuracy will be analyzed next.

5.4

Prediction Accuracy

Experimental results on four datasets show that the proposed CF framework helps existing CF algorithms to improve their accuracy in a large range of density requirements.
The experimental results on the RMSE versus the density
requirement is shown in Figure 9. Each sub-figure presents

Figure 10: Location of the four highly related cities.

320

Table 3: Best RMSE of the CF framework based on Accurate (Acc.) and Approximate (App.) BBDF
structures on the four datasets and the corresponding density requirement ρ. The standard deviations are ≤
0.006 on MovieLens and DianPing dataset and ≤ 0.05 on Yahoo! Music dataset.
MovieLens-100K
base Acc.BBDF App.BBDF
RMSE ρ RMSE ρ RMSE
User-based 0.936 0.085 0.927 0.085 0.914
Item-based 0.924 0.080 0.915 0.080 0.913
SVD
0.913 0.085 0.902 0.090 0.895
NMF
0.909 0.085 0.896 0.090 0.893
Method

MovieLens-1M
base Acc.BBDF App.BBDF
RMSE ρ RMSE ρ RMSE
0.887 0.070 0.876 0.070 0.856
0.871 0.070 0.859 0.065 0.858
0.859 0.065 0.845 0.070 0.830
0.854 0.075 0.842 0.075 0.823

Table 5: Speedups of conducting collaborative filtering based on (A)BBDF structures on four datasets.

scattered communities could give bad predictions because
of over-fitting problems, which leads to a decrease in the
performance when high density requirements are used.
Table 3 presents the best performance of each CF method
on each dataset for accurate and approximate BBDF frameworks. A bold number indicates an obvious improvement,
where the RMSE is reduced more than 0.02 on MovieLens
and Dianping or more than 0.4 on Yahoo! Music.
When calculating the average RMSE on each dataset, fivefold cross-validation was conducted on MovieLens and DianPing, and experiments were conducted five times on Yahoo!Music. Standard deviations were ≤ 0.006 on MovieLens
and DianPing and were ≤ 0.05 on Yahoo! Music.
We see that both accurate and approximate BBDF benefits CF algorithms in the best cases, and approximate BBDF
tends to achieve better performance.

5.5

Dataset
User
Item
SVD
NMF

6.

Scalability and Efficiency

Table 4: Computational time of the BBDF and
ABBDF algorithms on the four datasets.
ML-100K
85.6ms
521.8ms

ML-1M
1.61s
6.43s

Dianping
21.2s
80.3s

Yahoo!
42.6min
103.4min

Experiments show that the computational time of the
BBDF algorithms increases along with the scale of rating
matrices, but the time used for BBDF permutation is small
compared with the CF prediction algorithms. Moreover,
once BBDF structures have been constructed, they help to
decrease the total prediction time by conducting collaborative filtering on smaller submatrices, especially for userbased and item-based methods. We calculated the average
speedups for each CF algorithm on each dataset, as shown
in Table 5, where speedup is defined as:
Sp =

TCF
TBBDF + TBBDF

ML-100K
acc. app.
1.28 1.25
1.15 1.19
1.10 1.11
1.07 1.02

ML-1M
acc. app.
1.24 1.21
1.21 1.18
1.16 1.28
1.20 1.17

Dianping
acc. app.
1.33 1.21
1.39 1.29
1.30 1.28
1.26 1.32

Yahoo!
acc. app.
1.46 1.34
1.54 1.47

DISCUSSION

In practical real-world recommender systems, rating matrices are usually changing continuously as new ratings are
made by users. However, (A)BBDF structures make it possible to re-predict the submatrices that are truly in need of
re-prediction, for example, those whose RMSE have reached
a criterion, rather than to re-predict the whole matrix, which
might further contribute to the scalability in real-world recommender systems.
The cold-start problem has long been an important issue in the research of collaborative filtering. By inserting a
new user or item into a proper community and making recommendations there, the framework could benefit the coldstart recommendation. Additionally, ABBDF structure distinguishes a user’s special interests from the general interests of his or her community, which could contribute to the
serendipity of the recommendations, and these issues will be
investigated in future work.
Although the (A)BBDF permutation algorithms have only
one tunable parameter density requirement ρ, it could be difficult to determine a proper ρ given a new dataset in real
applications because too low or too high density requirements might both not give the best performance, which is
currently a shortcoming of the algorithms. Further work
will be performed to investigate the possibility of learning
proper density requirements automatically.

Experiments were conducted on a linux server with 8 core
3.1GHz CPU and 64GB RAM. For both accurate and approximate BBDF algorithms on each dataset, we averaged
the computational time consumed under different density
requirements, as shown in Table 4.

Dataset
accBDF
appBDF

Dianping
Yahoo! Music
base Acc.BBDF App.BBDF base Acc.BBDF
App.BBDF
RMSE ρ RMSE ρ RMSE RMSE
ρ
RMSE
ρ
RMSE
0.887 0.025 0.864 0.030 0.854
0.0045 24.443 0.0035 24.798
0.925 0.015 0.911 0.025 0.911
0.0030 24.002 0.0025 24.020
0.850 0.025 0.831 0.020 0.832 22.746 0.0020 22.469 0.0025 22.434
0.843 0.030 0.824 0.020 0.818 23.572 0.0030 23.223 0.0040 23.124

7.

CONCLUSIONS

In this paper, we investigated the relationship between
(A)BBDF structures and community detection on user-item
bipartite graphs, and we proposed algorithms that, in fact,
need only one intuitional parameter density requirement to
permute a matrix into (A)BBDF structures. We further
proposed a general collaborative filtering framework that is
based on (A)BBDF structures to make rating predictions.
Experimental results show that, by utilizing user-item communities contained in these structures, the proposed framework benefits many CF algorithms improving their prediction accuracies, and at the same time contributes to system
scalability, which means that (A)BBDF structures tend to
be a general and promising framework to improve the performance of existing CF algorithms.

CF

TCF is the time used by a CF prediction algorithm on the
whole matrix, TBBDF is the time of accurate or approximate
BBDF permutation algorithms, and TBBDF CF is the time
of CF prediction algorithms on (A)BBDF structures.
The experimental results show that in almost all of the
cases, (A)BBDF structures speed up rating prediction; the
speedup is obvious especially for nearest neighbor CF methods and large datasets.

321

8.

ACKNOWLEDGEMENT

[20] W. Lin, X. Kong, P. S. Yu, Q. Wu, Y. Jia, and C. Li.
Community Detection in Incomplete Information
Networks. Proc. WWW, pages 341–349, 2012.
[21] C. Liu, H. Yang, J. Fan, L. He, and Y. Wang.
Distributed Nonnegative Matrix Factorization for
Web-scale Dyadic Data Analysis on MapReduce. Proc.
WWW, pages 681–690, 2010.
[22] J. Liu, M. Z. Q. Chen, J. Chen, F. Deng, H. Zhang,
Z. Zhang, and T. Zhou. Recent Advances in Personal
Recommender Systems. Jour. Info. and Sys. Sci.,
5:230–247, 2009.
[23] F. Luo, J. Z. Wang, and E. Promislow. Exploring
Local Community Structures in Large Networks. Proc.
WI, 2006.
[24] T. Nakahara and H. Morita. Recommender System for
Music CDs Using a Graph Partitioning Method. Proc.
KES, 2009.
[25] J. Noel, S. Sanner, K. Tran, P. Christen, and L. Xie.
New Objective Functions for Social Collaborative
Filtering. Proc. WWW, pages 859–868, 2012.
[26] M. O’Connor and J. Herlocker. Clustering Items for
Collaborative Filtering. Proc. SIGIR Workshop, 1999.
[27] S. Oyanagi, K. Kubota, and A. Nakase. Application of
Matrix Clustering to Web Log Analysis and Access
Prediction. Proc. WEBKDD, pages 13–21, 2001.
[28] M. J. Pazzani and D. Billsus. Content-Based
Recommendation Systems. The Adaptive Web LNCS,
pages 325–341, 2007.
[29] P. Resnick, N. Iacovou, M. Suchak, P. Bergstrom, and
J. Riedl. GroupLens: An Open Architecture for
Collaborative Filtering of Netnews. CSCW, 1994.
[30] P. Sanders and C. Schulz. Engineering Multilevel
Graph Partitioning Algorithms. ESA, 2011.
[31] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl.
Item-Based Collaborative Filtering Recommendation
Algorithms. Proc. WWW, pages 285–295, 2001.
[32] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl.
Incremental Singular Value Decomposition Algorithms
for Highly Scalable Recommender Systems. Proc.
ICCIT, 2002.
[33] B. M. Sarwar, G. Karypis, J. A. Konstan, and J. T.
Riedl. Application of Dimensionality Reduction in
Recommender Systems - a case study. WebKDD, 2000.
[34] B. Savas and I. S. Dhillon. Clustered Low Rank
Approximation of Graphs in Information Science
Applications. Proc. SIAM SDM, pages 164–175, 2011.
[35] B. Savas and I. S. Dhillon. Clustered Low Rank
Approximation of Graphs in Information Science
Applications. Proc. SIAM SDM, pages 164–175, 2011.
[36] F. Wang, T. Li, X. Wang, S. Zhu, and C. Ding.
Community Discovery using Nonnegative Matrix
Factorization. Journal of DMKD, 22, 2011.
[37] Q. Wang, J. Xu, H. Li, and N. Craswell. Regularized
Latent Sematic Indexing. Proc. SIGIR, 2011.
[38] Y. Wu, Q. Yan, D. Bickson, et al. Efficient Multicore
Collaborative Filtering. KDDCUP, 2011.
[39] B. Xu, J. Bu, and C. Chen. An Exploration of
Improving Collaborative Recommender Systems via
User-Item Subgroups. WWW, pages 21–30, 2012.
[40] S. Zhang, W. Wang, J. Ford, and F. Makedon.
Learning from Incomplite Ratings Using Non-negative
Matrix Factorization. Proc. SIAM SDM, 2006.

The authors thank the anonymous reviewers for their constructive reviews and suggestions. This work was supported
by Natural Science Foundation (60903107,61073071) and National High Technology Research and Development (863)
Program (2011AA01A205) of China.

9.

REFERENCES

[1] C. Aykanat, A. Pinar, and U. V. Catalyurek.
Permuting Sparse Rectangular Matrices into
Block-Diagonal From. SISC, 2004.
[2] R. M. Bell and Y. Koren. Scalable Collaborative
Filtering with Jointly Derived Neighborhood
Interpolation Weights. Proc. ICDM, 2007.
[3] E. Boman and M. Wolf. A Nested Dissection approach
to Sparse Matrix Partitioning for Parallel
Computations. Proc. AMM, 2007.
[4] M. Brand. Fast online SVD revisions for lightweight
recommender systems. Proc. SIAM SDM, 2003.
[5] T. N. Bui and C. Jones. Finding Good Approximate
Vertex and Edge Partitions is NP-hard. Inform.
Process. Lett., 1992.
[6] J. Chen and Y. Saad. Dense Subgraph Extraction with
Application to Community Detection. TKDE, 2012.
[7] I. S. Dhillon, S. Mallela, and D. S. Modha.
Information Theoretic Co-clustering. Proc. SIGKDD,
pages 89–98, 2003.
[8] G. Dror, N. Koenigstein, Y. Koren, and M. Weimer.
The Yahoo! Music Dataset and KDD-Cup’11.
KDDCUP, 2011.
[9] S. Fortunato. Community Detection in Graphs.
Physics Reports, 486:75–174, 2010.
[10] R. Gemulla, E. Nijkamp, P. J. Haas, and Y. Sismanis.
Large-scale Matrix Factorization with Distributed
Stochastic Gradient Descent. KDD, 2011.
[11] T. George and S. Merugu. A Scalable Collaborative
Filtering Framework based on Co-clustering. Proc.
ICDM, 2005.
[12] M. Jahrer and A. Toscher. Collaborative Filtering
Ensemble. KDDCUP, 2011.
[13] G. Karypis. Metis-A Software Package for Partitioning
Unstructured Graphs, Meshes, and Computing
Fill-Reducing Orderings of Sparse Matrices-Version
5.0. University of Minnesota, 2011.
[14] G. Karypis and V. Kumar. A Fast and High Quality
Multilevel Scheme for Partitioning Irregular Graphs.
SISC, 1998.
[15] J. Kim, I. Hwang, Y. H. Kim, and B. R. Moon.
Genetic Approaches for Graph Partitioning: A
Survey. Proc. CECCO, pages 473–480, 2011.
[16] Y. Koren, R. Bell, and C. Volinsky. Matrix
Factorization Techniques for Recommender Systems.
Computer, 42:30–37, 2009.
[17] D. D. Lee and H. S. Seung. Algorithms for
Non-negative Matrix Factorization. NIPS, 2001.
[18] K. W. Leung, D. L. Lee, and W. Lee. CLR: A
Collaborative Location Recommendation Framework
based on Co-Clustering. Proc. SIGIR, 2011.
[19] T. Li, C. Gao, and J. Du. A NMF-based
Privacy-Preserving Recommendation Algorithm. Proc.
ICISE, 2009.

322

