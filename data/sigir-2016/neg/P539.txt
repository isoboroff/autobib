Collaborative Filtering Bandits
Shuai Li

Alexandros Karatzoglou

Claudio Gentile

University of Insubria, Italy

Telef√≥nica Research, Spain

University of Insubria, Italy

shuaili.sli@gmail.com

alexk@tid.es

ABSTRACT

set of items. In this classical setting, the well-known coldstart problem, namely, the lack of accumulated interactions
by users on items, needs to be addressed, for instance, by
turning to hybrid recommendation methods (e.g., [19]). In
practice, many relevant recommendation domains are dynamic, in the sense that user preferences and the set of
active users change with time. Recommendation domains
can be distinguished by how much and how often user preferences and content universe change (e.g., [24]). In highly
dynamic recommendation domains, such as news, ads and
videos, active users and user preferences are fluid, hence
classical collaborative filtering-type methods, such as Matrix or Tensor-Factorization break down. In these settings,
it is essential for the recommendation method to adapt to
the shifting preference patterns of the users.
Exploration-exploitation methods, a.k.a. multi-armed bandits, have been shown to be an excellent solution for these
dynamic domains (see, e.g., the news recommendation evidence in [23]). While effective, standard contextual bandits
do not take collaborative information into account, that is,
users who have interacted with similar items in the past
will not be deemed to have similar taste based on this fact
alone, while items that have been chosen by the same group
of users will also not be considered as similar. It is this significant limitation in the current bandit methodology that
we try to address in this work. Past efforts on this problem
were based on using online clustering-like algorithms on the
graph or network structure of the data in conjunction with
multi-armed bandit methods (see Section 3).
Commercial large scale search engines and information
retrieval systems are examples of highly dynamic environments where users and items could be described in terms of
their membership in some preference cluster. For instance,
in a music recommendation scenario, we may have groups of
listeners (the users) clustered around music genres, with the
clustering changing across different genres. On the other
hand, the individual songs (the items) could naturally be
grouped by sub-genre or performer based on the fact that
they tend to be preferred by the same group of users. Evidence has been collected which suggests that, at least in
specific recommendation scenarios, like movie recommendation, data are well modeled by clustering at both user and
item sides (e.g., [31]).
In this paper, we introduce a Collaborative Filtering based
stochastic multi-armed bandit method that allows for a flexible and generic integration of information of users and items
interaction data by alternatively clustering over both user
and item sides. Specifically, we describe and analyze an

Classical collaborative filtering, and content-based filtering
methods try to learn a static recommendation model given
training data. These approaches are far from ideal in highly
dynamic recommendation domains such as news recommendation and computational advertisement, where the set of
items and users is very fluid. In this work, we investigate
an adaptive clustering technique for content recommendation based on exploration-exploitation strategies in contextual multi-armed bandit settings. Our algorithm takes into
account the collaborative effects that arise due to the interaction of the users with the items, by dynamically grouping
users based on the items under consideration and, at the
same time, grouping items based on the similarity of the
clusterings induced over the users. The resulting algorithm
thus takes advantage of preference patterns in the data in
a way akin to collaborative filtering methods. We provide
an empirical analysis on medium-size real-world datasets,
showing scalability and increased prediction performance (as
measured by click-through rate) over state-of-the-art methods for clustering bandits. We also provide a regret analysis
within a standard linear stochastic noise setting.

Keywords
Filtering and Recommending; Recommender Systems; Online Learning; Collaborative Filtering; Clustering; Bandits;
Regret; Computational Advertising

1.

claudio.gentile@uninsubria.it

INTRODUCTION

Recommender Systems are an essential part of many successful on-line businesses, from e-commerce to on-line streaming, and beyond. Moreover, Computational Advertising can
be seen as a recommendation problem where the user preferences highly depend on the current context. In fact, many
recommendation domains such as Youtube video recommendation or news recommendation do not fit the classical description of a recommendation scenario, whereby a set of
users with essentially fixed preferences interact with a fixed
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.

SIGIR ‚Äô16, July 17-21, 2016, Pisa, Italy
c 2016 ACM. ISBN 978-1-4503-4069-4/16/07. . . $15.00
DOI: http://dx.doi.org/10.1145/2911451.2911548

539

adaptive and efficient clustering of bandit algorithm that
can perform collaborative filtering, named COFIBA (pronounced as ‚Äúcoffee bar‚Äù). Importantly enough, the clustering
performed by our algorithm relies on sparse graph representations, avoiding expensive matrix factorization techniques.
We adapt COFIBA to the standard setting of sequential
content recommendation known as (contextual) multi-armed
bandits (e.g., [5]) for solving the canonical exploration vs.
exploitation dilemma.
Our algorithm works under the assumption that we have
to serve content to users in such a way that each content
item determines a clustering over users made up of relatively few groups (compared to the total number of users),
within which users tend to react similarly when that item
gets recommended. However, the clustering over users need
not be the same across different items. Moreover, when the
universe of items is large, we also assume that the items
might be clustered as a function of the clustering they determine over users, in such a way that the number of distinct
clusterings over users induced by the items is also relatively
small compared to the total number of available items.
Our method aims to exploit collaborative effects in a bandit setting in a way akin to the way co-clustering techniques
are used in batch collaborative filtering. Bandit methods
also represent one of the most promising approaches to the
research community of recommender systems, for instance
in tackling the cold-start problem (e.g., [25]), whereby the
lack of data on new users leads to suboptimal recommendations. An exploration approach in these cases seems very
appropriate.
We demonstrate the efficacy of our dynamic clustering algorithm on three benchmark and real-world datasets. Our
algorithm is scalable and exhibits significant increased prediction performance over the state-of-the-art of clustering
‚àö
bandits. We also provide a regret analysis of the T -style
holding with high probability in a standard stochastically
linear noise setting.

known vector ui ‚àà Rd hosted at user i ‚àà U, in such a way
that if users i and i0 are in the same cluster w.r.t. x then
>
0
u>
i x = ui0 x, while if i and i are in different clusters w.r.t.
>
x then |u>
x
‚àí
u
x|
‚â•
Œ≥,
for
some (unknown) gap param0
i
i
eter Œ≥ > 0, independent of x.1 As in the standard linear
bandit setting (e.g., [5, 23, 12, 3, 13, 21, 30, 34, 16, 1], and
references therein), the unknown vector ui determines the
(average) behavior of user i. More concretely, upon receiving context vector x, user i ‚Äúreacts‚Äù by delivering a payoff
value
ai (x) = u>
i x + i (x) ,

2.

t
becomes a
as a binary feedback, so that the quantity t=1
T
clickthrough rate (CTR), where at = 1 if the recommended
item was clicked by user it , and at = 0, otherwise. CTR
is the measure of performance adopted by our comparative
experiments in Section 5.
From a theoretical standpoint (Section 6), we are instead
interested in bounding the cumulative regret achieved by our
algorithms. More precisely, let the regret rt of the learner at
time t be the extent to which the average payoff of the best
choice in hindsight at user it exceeds the average payoff of
the algorithm‚Äôs choice, i.e.,


>
rt = max u>
it x ‚àíuit xÃÑt .

where i (x) is a conditionally zero-mean and bounded variance noise term so that, conditioned on the past, the quantity u>
i x is indeed the expected payoff observed at user i
for context vector x. Notice that the unknown parameter
vector ui we associate with user i is supposed to be time
invariant in this model.2
Since we are facing sequential decision settings where the
learning system needs to continuously adapt to the newly
received information provided by users, we assume that the
learning process is broken up into a discrete sequence of
rounds: In round t = 1, 2, . . . , the learner receives a user
index it ‚àà U to serve content to, hence the user to serve
may change at every round, though the same user can recur many times. We assume the sequence of users i1 , i2 , . . .
is determined by an exogenous process that places nonzero
and independent probability to each user being the next one
to serve. Together with it , the system receives in round t
a set of feature vectors Cit = {xt,1 , xt,2 , . . . , xt,ct } ‚äÜ Rd
encoding the content which is currently available for recommendation to user it . The learner is compelled to pick
some xÃÑt = xt,kt ‚àà Cit to recommend to it , and then observes it ‚Äôs feedback in the form of payoff at ‚àà R whose
(conditional) expectation is u>
it xÃÑt . The goal of the learnPT
ing system is to maximize its total payoff
t=1 at over T
rounds. When the user feedback at our disposal is only the
click/no-click behavior, the payoff at is naturally interpreted
PT

LEARNING MODEL

We assume that the user behavior similarity is encoded by
a family of clusterings depending on the specific feature (or
context, or item) vector x under consideration. Specifically,
we let U = {1, . . . , n} represent the set of n users. Then,
given x ‚àà Rd , set U can be partitioned into a small number
m(x) of clusters U1 (x), U2 (x), . . . , Um(x) (x), where m(x) is
upper bounded by a constant m, independent of x, with
m being much smaller than n. (The assumption m << n
is not strictly required but it makes our algorithms more
effective, and this is actually what we expect our datasets
to comply with.) The clusters are such that users belonging to the same cluster Uj (x) tend to have similar behavior w.r.t. feature vector x (for instance, they both like or
both dislike the item represented by x), while users lying in
different clusters have significantly different behavior. The
mapping x ‚Üí {U1 (x), U2 (x), . . . , Um(x) (x)} specifying the
actual partitioning of the set of users U into the clusters determined by x (including the number of clusters m(x) and
its upper bound m), as well as the common user behavior
within each cluster are unknown to the learning system, and
have to be inferred based on user feedback.
For the sake of simplicity, this paper takes the simple
viewpoint that clustering over users is determined by linear functions x ‚Üí u>
i x, each one parameterized by an un-

a

x‚ààCit

We are aimedPat bounding with high probability the cumulative regret Tt=1 rt , the probability being over the noise
variables it (xÃÑt ), and any other possible source of randomness, including it ‚Äì see Section 6.
1
As usual, this assumption may be relaxed by assuming the
existence of two thresholds, one for the within-cluster dis>
tance of u>
i x to ui0 x, the other for the between-cluster distance.
2
It would in fact be possible to lift this whole machinery
to time-drifting user preferences by combining with known
techniques (e.g., [11, 28]).

540

The kind of regret bound we would like to contrast to is
one where the latent clustering structure over U (w.r.t. the
feature vectors x) is somehow known beforehand (see Section 6 for details). When the content universe is large but
known a priori, as is frequent in many collaborative filtering applications, it is often desirable to also group the items
into clusters based on similarity of user preferences, i.e., two
items are similar if they are preferred by many of the same
users. This notion of ‚Äútwo-sided‚Äù clustering is well known in
the literature; when the clustering process is simultaneously
grouping users based on similarity at the item side and items
based on similarity at the user side, it goes under the name of
‚Äúco-clustering‚Äù (see, e.g., [14, 15]). Here, we consider a computationally more affordable notion of collaborate filtering
based on adaptive two-sided clustering.
Unlike previous existing clustering techniques on bandits (e.g., [1, 29]), our clustering setting only applies to
the case when the content universe is large but known a
priori (yet, see the end of Section 4). Specifically, let the
content universe be I = {x1 , x2 , . . . , x|I| }, and P (xh ) =
{U1 (xh ), U2 (xh ), . . . , Um(xh ) (xh )} be the partition into clusters over the set of users U induced by item xh . Then items
xh , xh0 ‚àà I belong to the same cluster (over the set of items
I) if and only if they induce the same partition of the users,
i.e., if P (xh ) = P (xh0 ). We denote by g the number of distinct partitions so induced over U by the items in I, and
work under the assumption that g is unknown but significantly smaller than |I|. (Again, the assumption g << |I|
is not strictly needed, but it both makes our algorithms effective and is expected to be satisfied in relevant practical
scenarios.)
Finally, in all of the above, an important special case is
when the items to be recommended do not possess specific
features (or do not possess features having significant predictive power). In this case, it is common to resort to the
more classical non-contextual stochastic multiarmed bandit setting (e.g., [6, 4]), which is recovered from the contextual framework by setting d = |I|, and assuming the
content universe I is made up of the d-dimensional vectors
eh , h = 1, . . . , d, of the canonical basis of Rd , As a consequence, the expected payoff of user i on item h is simply the
h-th component of vector ui , and two users i and i0 belong
to the same cluster w.r.t. to h if the h-th component of ui
equals the h-th component of ui0 . Because the lack of useful
annotation on data was an issue with all datasets at our disposal, it is this latter modeling assumption that motivates
the algorithm we actually implemented for the experiments
reported in Section 5.

3.

based on the scheme of collaborative filtering; the papers
which are most closely related to ours are [16, 27, 29, 8,
22, 1, 2]. In [16], the authors work under the assumption
that users are defined using a feature vector, and try to
learn a low-rank hidden subspace assuming that variation
across users is low-rank. The paper combines low-rank matrix recovery with high-dimensional Gaussian Process Bandits, but it gives rise to algorithms which do not seem practical for sizeable problems. In [27], the authors analyze a
non-contextual stochastic bandit problem where model parameters are assumed to be clustered in a few (unknown)
types. Yet, the provided solutions are completely different
from ours. The work [29] combines (k-means-like) online
clustering with a contextual bandit setting, but clustering
is only made at the user side. The paper [8] also relies on
bandit clustering at the user side (as in [27, 29]), with an
emphasis on diversifying recommendations to the same user
over time. In [22], the authors propose cascading bandits of
user behavior to identify the k most attractive items, and
formulate it as a stochastic combinatorial partial monitoring
problem. Finally, the algorithms in [1, 2, 26] can be seen as
a special case of COFIBA when clustering is done only at
the user side, under centralized [1, 26] or decentralized [2]
environments.
Similar in spirit are also [7, 9, 10, 20]: In [7], the authors
define a transfer learning problem within a stochastic multiarmed bandit setting, where a prior distribution is defined
over the set of possible models over the tasks; in [9], the
authors rely on clustering Markov Decision Processes based
on their model parameter similarity. In [10], the authors
discuss how to choose from n unknown distributions the k
ones whose means are largest by a certain metric; in [20]
the authors study particle Thompson sampling with RaoBlackwellization for online matrix factorization, exhibiting a
regret bound in a very specific case of n√óm rank-1 matrices.
Yet, in none of above cases did the authors make a specific
effort towards item-dependent clustering models applied to
stochastic multi-armed bandits.
Further work includes [25, 32]. In [25], an ensemble of
contextual bandits is used to address the cold-start problem
in recommender systems. A similar approach is used in [32]
to deal with cold-start in recommender systems but based
on the probability matching paradigm in a parameter-free
bandit strategy, which employs online bootstrap to derive
the distribution of the estimated models. In contrast to
our work, in neither [25] nor [32] are collaborative effects
explicitly taken into account.

4.

RELATED WORK

THE ALGORITHM

COFIBA, relies on upper-confidence-based tradeoffs between exploration and exploitation, combined with adaptive
clustering procedures at both the user and the item sides.
COFIBA stores in round t an estimate wi,t of vector ui
associated with user i ‚àà U . Vectors wi,t are updated based
on the payoff feedback, as in a standard linear least-squares
approximation to the corresponding ui . Every user i ‚àà U
hosts such an algorithm which operates as a linear bandit algorithm (e.g., [12, 3, 1]) on the available content Cit . More
specifically, wi,t‚àí1 is determined by an inverse correlation
‚àí1
matrix Mi,t‚àí1
subject to rank-one adjustments, and a vector
bi,t‚àí1 subject to additive updates. Matrices Mi,t are initialized to the d √ó d identity matrix, and vectors bi,t are initial‚àí1
ized to the d-dimensional zero vector. Matrix Mi,t‚àí1
is also

Batch collaborative filtering neighborhood methods rely
on finding similar groups of users and items to the target
user-item pair, e.g., [33], and thus in effect rely on a dynamic
form of grouping users and items. Collaborative Filteringbased methods have also been integrated with co-clustering
techniques, whereby preferences in each co-cluster are modeled with simple statistics of the preference relations in the
co-cluster, e.g., rating averages [18].
Beyond the general connection to co-clustering (e.g., [14,
15]), our paper is related to the research on multi-armed bandit algorithms for trading off exploration and exploitation
through dynamic clustering. We are not aware of any specific piece of work that combines bandits with co-clustering

541

used to define an upper confidence bound cbi,t‚àí1 (x) in the
approximation of wi,t‚àí1 to ui along direction x. Based on
the local information encoded in the weight vectors wi,t‚àí1
and the confidence bounds cbi,t‚àí1 (x), the algorithm also
maintains and updates a family of clusterings of the set of
users U, and a single clustering over the set of items I. On
both sides, such clusterings are represented through connected components of undirected graphs (this is in the same
vein as in [1]), where nodes are either users or items. A
pseudocode description of our algorithm is contained in Figures 1, 2, and 3, while Figure 4 illustrates the algorithm‚Äôs
behavior through a pictorial example.
At time t, COFIBA receives the index it of the current user to serve, along with the available item vectors
xt,1 , . . . , xt,ct , and must select one among them. In order
to do so, the algorithm computes the ct neighborhood sets
Nk , one per item xt,k ‚àà Cit based on the current aggregation of users (clusters ‚Äúat the user side‚Äù) w.r.t. item xt,k .
Set Nk should be regarded as the current approximation to
the cluster (over the users) it belongs to when the clustering criterion is defined by item xt,k . Each neighborhood set
then defines a compound weight vector wÃÑNk ,t‚àí1 (through
the aggregation of the corresponding matrices Mi,t‚àí1 and
vectors bi,t‚àí1 ) which, in turn, determines a compound confidence bound3 cbNk ,t‚àí1 (xt,k ). Vector wÃÑNk ,t‚àí1 and confidence bound cbNk ,t‚àí1 (xt,k ) are combined through an upperconfidence exploration-exploitation scheme so as to commit
to the specific item xÃÑt ‚àà Cit for user it . Then, the payoff
at is received, and the algorithm uses xÃÑt to update Mit ,t‚àí1
to Mit ,t and bit ,t‚àí1 to bit ,t . Notice that the update is only
performed at user it , though this will affect the calculation
of neighborhood sets and compound vectors for other users
in later rounds.
After receiving payoff at and computing Mit ,t and bit ,t ,
COFIBA updates the clusterings at the user side and the
(unique) clustering at the item side. In round t, there are
U
multiple graphs GU
t,h = (U, Et,h ) at the user side (hence
many clusterings over U, indexed by h), and a single graph
GIt = (I, EtI ) at the item side (hence a single clustering
over I). Each clustering at the user side corresponds to a
single cluster at the item side, so that we have gt clusters
IÀÜ1,t , . . . , IÀÜgt ,t over items and gt clusterings over users ‚Äì see
Figure 4 for an example. On both user and item sides, updates take the form of edge deletions. Updates at the user
side are only performed on the graph GU
b t pointed to by
t,h
the selected item xÃÑt = xt,kt . Updates at the item side are
only made if it is likely that the neighborhoods of user it has
significantly changed when considered w.r.t. two previously
deemed similar items. Specifically, if item xh was directly
connected to item xÃÑt at the beginning of round t and, as a
consequence of edge deletion at the user side, the set of users
that are now likely to be close to it w.r.t. xh is no longer
the same as the set of users that are likely to be close to it
w.r.t. xÃÑt , then this is taken as a good indication that item
xh is not inducing the same partition over users as xÃÑt does,
hence edge (xÃÑt , xh ) gets deleted. Notice that this need not
imply that, as a result of this deletion, the two items are
now belonging to different clusters over I, since these two
items may still be indirectly connected.

Input:
‚Ä¢ Set of users U = {1, . . . , n};
‚Ä¢ set of items I = {x1 , . . . , x|I| } ‚äÜ Rd ;
‚Ä¢ exploration parameter Œ± > 0, and edge deletion parameter Œ±2 > 0.
Init:
‚Ä¢ bi,0 = 0 ‚àà Rd and Mi,0 = I ‚àà Rd√ód , i = 1, . . . n;
U
U
‚Ä¢ User graph GU
1,1 = (U , E1,1 ), G1,1 is connected over U ;

‚Ä¢ Number of user graphs g1 = 1;
‚Ä¢ No. of user clusters mU
1,1 = 1;
‚Ä¢ Item clusters IÀÜ1,1 = I, no. of item clusters g1 = 1;
‚Ä¢ Item graph GI1 = (I, E1I ), GI1 is connected over I.
for t = 1, 2, . . . , T do
Set
‚àí1
wi,t‚àí1 = Mi,t‚àí1
bi,t‚àí1 ,

i = 1, . . . , n ;

Receive it ‚àà U , and get items Cit = {xt,1 , . . . , xt,ct } ‚äÜ I;
For each k = 1, . . . , ct , determine which cluster (within the
current user clustering w.r.t. xt,k ) user it belongs to, and
denote this cluster by Nk ;
Compute, for k = 1, . . . , ct , aggregate quantities
X
MÃÑNk ,t‚àí1 = I +
(Mi,t‚àí1 ‚àí I),
i‚ààNk

bÃÑNk ,t‚àí1 =
wÃÑNk ,t‚àí1 =
Set

kt = argmax
k=1,...,ct



X

bi,t‚àí1 ,
i‚ààNk
‚àí1
MÃÑN
bÃÑNk ,t‚àí1
k ,t‚àí1

;


wÃÑ>
Nk ,t‚àí1 xt,k + cbNk ,t‚àí1 (xt,k ) ,

q
‚àí1
x log(t + 1) ;
where cbNk ,t‚àí1 (x) = Œ± x> MÃÑN
k ,t‚àí1
Set for brevity xÃÑt = xt,kt ;
Observe payoff at ‚àà R, and update weights Mi,t and bi,t as
follows:
‚Ä¢

Mit ,t = Mit ,t‚àí1 + xÃÑt xÃÑ>
t ,

‚Ä¢

bit ,t = bit ,t‚àí1 + at xÃÑt ,

‚Ä¢

Set Mi,t = Mi,t‚àí1 , bi,t = bi,t‚àí1 for all i 6= it ,

Determine b
ht ‚àà {1, . . . , gt } such that kt ‚àà IÀÜh
b

t ,t

Update user clusters at graph GUb

t,ht

;

= (U , E Ub ) by pert,ht

forming the steps in Figure 2;
U
For all h 6= b
ht , set GU
t+1,h = Gt,h ;
Update item clusters at graph GIt = (I, EtI ) by performing
the steps in Figure 3 .
end for

Figure 1: The COFIBA algorithm.
Update user clusters at graph GUb as follows:
t,ht

‚Ä¢ Delete from E Ub all (it , j) such that
t,ht

>
|w>
it ,t xÃÑt ‚àí w j,t xÃÑt | > cbit ,t (xÃÑt ) + cbj,t (xÃÑt ) ,

where cbi,t (x) = Œ±2
‚Ä¢ Let
GU

EU b
t+1,ht

bt
t+1,h

q

‚àí1
x> Mi,t
x log(t + 1) ;

be the resulting set of edges,

= (U , E U

bt
t+1,h

ters UÃÇ1,t+1,h
b , UÃÇ2,t+1,h
b , . . . , UÃÇmU
t

nected components of

3
The one given in Figure 1 is the confidence bound we use
in our experiments. In fact, the theoretical counterpart to
cb is significantly more involved, same efforts can also be
found in order to close the gap, e.g., in [4, 1].

t

GU b .
t+1,ht

b
t+1,h
t

bt
,t+1,h

as the con-

Figure 2: User cluster update in the COFIBA

542

set

), and compute associated clus-

Update item clusters at graph GIt as follows:
‚Ä¢ For all ` such that (xÃÑt , x` ) ‚àà EtI build neighborhood
U
N`,t+1
(it ) as:
n
U
>
N`,t+1
(it ) = j : j 6= it , |w>
it ,t x` ‚àí w j,t x` |
o
‚â§ cbit ,t (x` ) + cbj,t (x` ) ;
U
‚Ä¢ Delete from EtI all (xÃÑt , x` ) such that N`,t+1
(it ) 6=
NkUt ,t+1 (it ), where NkUt ,t+1 (it ) is the neighborhood of
node it w.r.t. graph GU b ;
t+1,ht

I
‚Ä¢ Let Et+1
be the resulting set of edges, set
I
I ), compute associated item clusGt+1 = (I, Et+1
ÀÜ
ÀÜ
ters I1,t+1 , I2,t+1 , . . . , IÀÜgt+1 ,t+1 through the connected
components of GIt+1 ;

‚Ä¢ For each new item cluster created, allocate a new connected graph over users representing a single (degenerate) cluster U .

Figure 3: Item cluster update in the COFIBA
It is worth stressing that a naive implementation of
COFIBA would require memory allocation for maintaining |I|-many n-node graphs, i.e., O(n2 |I|). Because this
would be prohibitive even for moderately large sets of users,
we make full usage of the approach of [1], where instead of
starting off with complete graphs over users each time a new
cluster over items is created, we randomly sparsify the complete graph by drawing an Erdos-Renyi initial graph, still
retaining with high probability the underlying clusterings
{U1 (xh ), . . . , Um(xh ) (xh )}, h = 1, . . . , |I|, over users. This
works under the assumption that the latent clusters Ui (xh )
are not too small ‚Äì see the argument in [1], where it is shown
that in practice the initial graphs can have O(n log n) edges
instead of O(n2 ). Moreover, because we modify the item
graph by edge deletions only, one can show that with high
probability (under the modeling assumptions of Section 2)
the number gt of clusters over items remains upper bounded
by g throughout the run of COFIBA, so that the actual storage required by the algorithm is indeed O(ng log n). This
also brings a substantial saving in running time, since updating connected components scales with the number of edges
of the involved graphs. It is this graph sparsification techniques that we used and tested along the way in our experimentation parts.
Finally, despite we have described in Section 2 a setting
where I and U are known a priori (the analysis in Section
6 currently holds only in this scenario), nothing prevents in
practice to adapt COFIBA to the case when new content
or new users show up. This essentially amounts to adding
new nodes to the graphs at either the item or the user side,
by maintaining data-structures via dynamic memory allocation. In fact, this is precisely how we implemented our
algorithm in the case of very big item or user sets (e.g., the
Telefonica and the Avazu dataset in the next section).

5.

Figure 4: In this example, U = {1, . . . 6} and I =
{x1 , . . . , x8 } (the items are depicted here as 1, 2, . . . , 8).
(a) At the beginning we have g1 = 1, with a single item cluster IÀÜ1,1 = I and, correspondingly, a
single (degenerate) clustering over U, made up of
the unique cluster U. (b) In round t we have the
gt = 3 item clusters IÀÜ1,t = {x1 , x2 }, IÀÜ2,t = {x3 , x4 , x5 },
IÀÜ3,t = {x6 , x7 , x8 }. Corresponding to each one of them
are the three clusterings over U depicted on the left,
U
U
so that mU
In this
t,1 = 3, mt,2 = 2, and mt,3 = 4.
example, it = 4, and xÃÑt = x5 , hence b
ht = 2, and we
focus on graph GU
t,2 , corresponding to user clustering
{{1, 2, 3}, {4, 5, 6}}. Suppose in GU
t,2 the only neighbors
of user 4 are 5 and 6. When updating such user clustering, the algorithm considers therein edges (4, 5)
and (4, 6) to be candidates for elimination. Suppose
edge (4, 6) is eliminated, so that the new clustering
over U induced by the updated graph GU
t+1,2 becomes
{{1, 2, 3}, {4, 5}, {6}}. After user graph update, the algorithm considers the item graph update. Suppose
x5 is only connected to x4 and x3 in GIt , and that
x4 is not connected to x3 , as depicted. Both edge
(x5 , x4 ) and edge (x5 , x3 ) are candidates for elimination. The algorithm computes the neighborhood
N of it = 4 according to GU
t+1,2 , and compares it to
U
the the neighborhoods N`,t+1
(it ), for ` = 3, 4. AsU
sume N 6= N3,t+1
(it ), because the two neighborhoods
of user 4 are now different, the algorithm deletes
edge (x5 , x3 ) from the item graph, splitting the item
cluster {x3 , x4 , x5 } into the two clusters {x3 } and
{x4 , x5 }, hence allocating a new cluster at the item
side corresponding to a new degenerate clustering
{{1, 2, 3, 4, 5, 6}} at the user side. (c) The resulting
clusterings at the beginning of round t + 1. (In
this picture it is assumed that edge (x5 , x4 ) was not
deleted from the item graph at time t.)

EXPERIMENTS

We compared our algorithm to standard bandit baselines on three real-world datasets: one canonical benchmark
dataset on news recommendations, one advertising dataset
from a living production system, and one publicly available
advertising dataset. In all cases, no features on the items
have been used. We closely followed the same experimen-

tal setting as in previous work [12, 1], thereby evaluating
prediction performance by click-through rate.

5.1

Datasets

Yahoo!. The first dataset we use for the evaluation is the

543

freely available benchmark dataset which was released in the
‚ÄúICML 2012 Exploration & Exploitation Challenge‚Äù4 . The
aim of the challenge was to build state-of-the-art news article recommendation algorithms on Yahoo! data, by building
an algorithm that learns efficiently a policy to serve news
articles on a web site. The dataset is made up of random
traffic records of user visits on the ‚ÄúToday Module‚Äù of Yahoo!, implying that both the visitors and the recommended
news article are selected randomly. The available options
(the items) correspond to a set of news articles available for
recommendation, one being displayed in a small box on the
visited web page. The aim is to recommend an interesting
article to the user, whose interest in a given piece of news
is asserted by a click on it. The data has 30 million visits
over a two-week time stretch. Out of the logged information
contained in each record, we used the user ID in the form
of a 136-dimensional boolean vector containing his/her features (index it ), the set of relevant news articles that the
system can recommend from (set Cit ); a randomly recommended article during the visit; a boolean value indicating
whether the recommended article was clicked by the visiting user or not (payoff at ). Because the displayed article
is chosen uniformly at random from the candidate article
pool, one can use an unbiased off-line evaluation method to
compare bandit algorithms in a reliable way. We refer the
reader to [1] for a more detailed description of how this
dataset was collected and extracted. We picked the larger
of the two datasets considered in [1], resulting in n ‚âà 18K
users, and d = 323 distinct items. The number of records
ended up being 2.8M , out of which we took the first 300K
for parameter tuning, and the rest for testing.
Telefonica. This dataset was obtained from Telefonica S.A., which is the number one Spanish broadband and
telecommunications provider, with business units in Europe
and South America. This data contains clicks on ads displayed to user on one of the websites that Telefonica operates on. The data were collected from the back-end server
logs, and consist of two files: the first file contains the ads
interactions (each record containing an impression timestamp, a user-ID, an action, the ad type, the order item ID,
and the click timestamp); the second file contains the ads
metadata as item-ID, type-ID, type, order-ID, creative type,
mask, cost, creator-ID, transaction key, cap type. Overall,
the number n of users was in the scale of millions, while
the number d of items was approximately 300. The data
contains 15M records, out of which we took the first 1, 5M
for parameter tuning, and the rest for testing. Again, the
only available payoffs are those associated with the items
served by the system. Hence, in order to make the procedure be an effective estimator in a sequential decision process
(e.g., [13, 17, 1, 23]), we simulated random choices by the
system by generating the available item sets Cit as follows:
At each round t, we stored the ad served to the current user
it and the associated payoff value at (1 =‚Äúclicked‚Äù, 0 =‚Äúnot
clicked‚Äù). Then we created Cit by including the served ad
along with 9 extra items (hence ct = 10 ‚àÄt) which were
drawn uniformly at random in such a way that, for any item
eh ‚àà I, if eh occurs in some set Cit , this item will be the
one served by the system 1/10 of the times. The random
selection was done independent of the available payoff val-

ues at . All our experiments on this dataset were run on a
machine with 64GB RAM and 32 Intel Xeon cores.
Avazu. This dataset was prepared by Avazu Inc,5 which
is a leading multinational corporation in the digital advertising business. The data was provided for the challenge
to predict the click-through rate of impressions on mobile
devices, i.e., whether a mobile ad will be clicked or not.
The number of samples was around 40M , out of which we
took the first 4M for parameter tuning, and the remaining
for testing. Each line in the data file represents the event
of an ad impression on the site or in a mobile application
(app), along with additional context information. Again,
payoff at is binary. The variables contained in the dataset
for each sample are the following: ad-ID; timestamp (date
and hour); click (boolean variable); device-ID; device IP;
connection type; device type; ID of visited App/Website;
category of visited App/Website; connection domain of visited App/Website; banner position; anonymized categorical
fields (C1, C14-C21). We pre-processed the dataset as follows: we cleaned up the data by filtering out the records
having missing feature values, and removed outliers. We
identified the user with device-ID, if it is not null. The
number of users on this dataset is in the scale of millions.
Similar to the Telefonica dataset, we generated recommendation lists of length ct = 20 for each distinct timestamp.
We used the first 4M records for tuning parameters, and
the remaining 36M for testing. All data were transferred to
Amazon S3, and all jobs were run through the Amazon EC2
Web Service.

4

5

5.2

Algorithms

We compared COFIBA to a number of state-of-the-art
bandit algorithms:
‚Ä¢ LINUCB-ONE is a single instance of the ucb1 [6]
algorithm, which is a very popular and established algorithm that has received a lot of attention in the research community over the past years;
‚Ä¢ DYNUCB is the dynamic ucb algorithm of [29]. This
algorithm adopts a ‚ÄúK-means‚Äù-like clustering technique so as to dynamically re-assign the clusters on
the fly based on the changing contexts and user preferences over time;
‚Ä¢ LINUCB-IND [1] is a set of independent ucb1 instances, one per user, which provides a fully personalized recommendation for each user;
‚Ä¢ CLUB [1] is the state-of-the-art online clustering of
bandits algorithm that dynamically cluster users based
on the confidence ellipsoids of their models;
‚Ä¢ LINUCB-V [4] is also a single instance of ucb1, but
with a more sophisticated confidence bound; this algorithm turned out to be the winner of the ‚ÄúICML 2012
Challenge‚Äù where the Yahoo! dataset originates from.
We tuned the optimal parameters in the training set with a
standard grid search as indicated in [13, 1], and used the test
set to evaluate the predictive performance of the algorithms.
Since the system‚Äôs recommendation need not coincide with
the recommendation issued by the algorithms we tested, we
only retained the records on which the two recommendations
were indeed the same. Because records are discarded on

https://explochallenge.inria.fr/category/challenge

544

https://www.kaggle.com/c/avazu-ctr-prediction

Telefonica Dataset
Yahoo Dataset

0.05

0.08

0.045

LINUCB‚àíONE
DYNUCB
LINUCB‚àíIND
CLUB
LINUCB‚àíV
COFIBA

0.07

0.035

0.05

0.03
CTR

CTR

0.04
0.06

0.04

0.02
0.01
0

0.02

LINUCB‚àíONE
DYNUCB
LINUCB‚àíIND
CLUB
LINUCB‚àíV
COFIBA

0.03

0.025

0.015
0.01
0.005
0

1

2

3

4
Rounds

5

6

0.5

7

1

1.5
2
Rounds

4

2.5

3
5

x 10

x 10

Figure 5: Results on the Yahoo dataset.

Figure 6: Results on the Telefonica dataset.

the fly, the actual number T of retained records (‚ÄúRounds‚Äù
in the plots of the next subsection) changes slightly across
algorithms; T was around 70K for the Yahoo! data, 350K
for the Telefonica data, and 900K for the Avazu data. All
experimental results we report were averaged over 3 runs
(but in fact the variance we observed across these runs was
fairly small).

Avazu Dataset
0.25

0.2

0.15

Results

CTR

5.3

Our results are summarized in Figures 5, 6, and 7. Further evidence is contained in Figure 8. In Figures 5‚Äì7, we
plotted click-through rate (‚ÄúCTR‚Äù) vs. retained records so
far (‚ÄúRounds‚Äù). All these experiments are aimed at testing
the performance of the various bandit algorithms in terms of
prediction performance, also in cold-start regimes (i.e., the
first relatively small fraction of the time horizon in the xaxis). Our experimental setting is in line with previous ones
(e.g., [12, 1]) and, by the way the data have been prepared,
gives rise to a reliable estimation of actual CTR behavior
under the same experimental conditions as in [12, 1]. Figure
8 is aimed at supporting the theoretical model of Section 2,
by providing some evidence on the kind of clustering statistics produced by COFIBA at the end of its run.
Whereas the three datasets we took into consideration are
all generated by real online web applications, it is worth
pointing out that these datasets are indeed different in the
way customers consume the associated content. Generally
speaking, the longer the lifecycle of one item the fewer the
items, the higher the chance that users with similar preferences will consume it, and hence the bigger the collaborative
effects contained in the data. It is therefore reasonable to
expect that our algorithm will be more effective in datasets
where the collaborative effects are indeed strong.
The users in the Yahoo! data (Figure 5), are likely to span
a wide range of demographic characteristics; on top of this,
this dataset is derived from the consumption of news that
are often interesting for large portions of these users and, as
such, do not create strong polarization into subcommunities.
This implies that more often than not, there are quite a few
specific hot news that all users might express interest in, and
it is natural to expect that these pieces of news are intended
to reach a wide audience of consumers. Given this state of
affairs, it is not surprising that on the Yahoo! dataset both
LINUCB-ONE and LINUCB-V (serving the same news to
all users) are already performing quite well, thereby making
the clustering-of-users effort somewhat less useful. This also
explains the poor performance of LINUCB-IND, which is

0.1

LINUCB‚àíONE
DYNUCB
LINUCB‚àíIND
CLUB
LINUCB‚àíV
COFIBA

0.05

0

1

2

3

4

5
Rounds

6

7

8

9
5

x 10

Figure 7: Results on the Avazu dataset.
not performing any clustering at all. Yet, even in this nontrivial case, COFIBA can still achieve a significant increased
prediction accuracy compared, e.g., to CLUB, thereby suggesting that simultaneous clustering at both the user and
the item (the news) sides might be an even more effective
strategy to earn clicks in news recommendation systems.
Most of the users in the Telefonica data are from a diverse
sample of people in Spain, and it is easy to imagine that this
dataset spans a large number of communities across its population. Thus we can assume that collaborative effects will
be much more evident, and that COFIBA will be able to
leverage these effects efficiently. In this dataset, CLUB performs well in general, while DYNUCB deteriorates in the
initial stage and catches-up later on. COFIBA seems to surpass all other algorithms, especially in the cold-start regime,
all other algorithms being in the same ballpark as CLUB.
Finally, the Avazu data is furnished from its professional
digital advertising solution platform, where the customers
click the ad impressions via the iOS/Android mobile apps
or through websites, serving either the publisher or the advertiser which leads to a daily high volume internet traffic.
In this dataset, neither LINUCB-ONE nor LINUCB-IND
displayed a competitive cold-start performance. DYNUCB
is underperforming throughout, while LINUCB-V demonstrates a relatively high CTR. CLUB is strong at the beginning, but then its CTR performance degrades. On the

545

0.4

datasets, the experimental evidence we collected on them
is quite consistent, in that in all the three cases COFIBA
significantly outperforms all other competing methods we
tested. This is especially noticeable during the cold-start
period, but the same relative behavior essentially shows up
during the whole time window of our experiments. COFIBA
is a bit involved to implement, as contrasted to its competitors, and is also somewhat slower to run (unsurprisingly
slower than, say, LINUCB-ONE and LINUCB-IND). On
the other hand, COFIBA is far more effective in exploiting the collaborative effects embedded in the data, and still
amenable to be run on large datasets.

0.3
0.2
0.1
0
0

2

4

6

8

10

12

14

16

18

0

2

4

6

8

10

12

14

16

18

2

4

6

8

10

12

14

16

18

0.8
0.6
0.4
0.2
0
0.8
0.6
0.4
0.2
0
0
0.5

6.

0.4

REGRET ANALYSIS

0.3

The following theorem is the theoretical guarantee
of COFIBA, where we relate the cumulative regret of
COFIBA to the clustering structure of users U w.r.t. items
I. For simplicity of presentation, we formulate our result
in the one-hot encoding case, where ui ‚àà Rd , i = 1, . . . , n,
and I = {e1 , . . . , ed }. In fact, a more general statement can
be proven which holds in the case when I is a generic set
of feature vectors I = {x1 , . . . , x|I| }, and the regret bound
depends on the geometric properties of such vectors.7
In order to obtain a provable advantage from our clusterability assumptions, extra conditions are needed on the
way it and Cit are generated. The clusterability assumptions we can naturally take advantage of are those where,
for most partitions P (eh ), the relative sizes of clusters over
users are highly unbalanced. Translated into more practical
terms, cluster unbalancedness amounts to saying that the
universe of items I tends to influence users so as to determine a small number of major common behaviors (which
need neither be the same nor involve the same users across
items), along with a number of minor ones. As we saw in
our experiments, this seems like a frequent behavior of users
in some practical scenarios.

0.2
0.1
0
0

2

4

6

8

10

12

14

16

18

2

4

6

8

10

12

14

16

18

0.5
0.4
0.3
0.2
0.1
0
0

Figure 8: A typical distribution of cluster sizes over
users for the Yahoo dataset. Each bar plot corresponds to a cluster at the item side. We have 5
plots since this is the number of clusters over the
items that COFIBA ended up with after sweeping
once over this dataset in the run at hand. Each
bar represents the fraction of users contained in the
corresponding cluster. For instance, the first cluster
over the items generated 16 clusters over the users
(bar plot on top), with relative sizes 31%, 15%, 12%,
etc. The second cluster over the items generated 10
clusters over the users (second bar plot from top)
with relative sizes 61%, 12%, 9%, etc. The relative
size of the 5 clusters over the items is as follows:
83%, 10%, 4%, 2%, and 1%, so that the clustering
pattern depicted in the top plot applies to 83% of
the items, the second one to 10% of the items, and
so on.

Theorem 1. Let the COFIBA algorithm of Figure 1 be
run on a set of users U = {1, . . . , n} with associated profile
vectors u1 , . . . , un ‚àà Rd , and set of items I = {e1 , . . . , ed }
such that the h-th induced partition P (eh ) over U is made
up of mh clusters of cardinality vh,1 , vh,2 , . . . , vh,mh , respectively. Moreover, let g be the number of distinct partitions so obtained. At each round t, let it be generated uniformly at random8 from U. Once it is selected, the number ct of items in Cit is generated arbitrarily as a function of past indices i1 , . . . , it‚àí1 , payoffs a1 , . . . , at‚àí1 , and sets
Ci1 , . . . , Cit‚àí1 , as well as the current index it . Then the sequence of items in Cit is generated i.i.d. (conditioned on it ,
ct and all past indices i1 , . . . , it‚àí1 , payoffs a1 , . . . , at‚àí1 , and
sets Ci1 , . . . , Cit‚àí1 ) according to a given but unknown distribution D over I. Let payoff at lie in the interval [‚àí1, 1],
and be generated as described in Section 2 so that, conditioned on history, the expectation of at is u>
it xÃÑt . Finally,
let parameters Œ± and Œ±2 be suitable functions of log(1/Œ¥). If
ct ‚â§ c ‚àÄt then, as T grows large, with probability at least

other hand, COFIBA seems to work extremely well during
the cold-start, and comparatively best in all later stages.
In Figure 8 we give a typical distribution of cluster sizes
produced by COFIBA after at the end of its run.6 The
emerging pattern is always the same: we have few clusters
over the items with very unbalanced sizes and, corresponding to each item cluster, we have few clusters over the users,
again with very unbalanced sizes. This recurring pattern is
in fact the motivation behind our theoretical assumptions
(Section 2), and a property of data that the COFIBA algorithm can provably take advantage of (Section 6). These bar
plots, combined with the comparatively good performance
of COFIBA, suggest that our datasets do actually possess
clusterability properties at both sides.
To summarize, despite the differences in the three

7
In addition, the function cb should be modified so as to
incorporate these properties.
8
Any distribution having positive probability on each i ‚àà U
would suffice here.

6

Without loss of generality, we take the first Yahoo dataset
to provide statistics, for similar shapes of the bar plots can
be established for the remaining ones.

546

1 ‚àí Œ¥ the cumulative regret satisfies9
!
r

q ‚àö
T
X
dT
e
rt = O
,
E[S] + c mn var(S) + 1
n
t=1
P h ‚àö
where S = S(h) = m
vh,j , h is a random index such
j=1
that eh ‚àº D, and E[¬∑] and var(¬∑) denote, respectively, the
expectation and the variance w.r.t. this random index.

by ht ), Tht ,jt ,t‚àí1 is the number of rounds so far where we
happened to ‚Äúhit‚Äù cluster Vht ,jt , i.e.,
Tht ,jt ,t‚àí1 = |{s ‚â§ t ‚àí 1 : is ‚àà Vht ,jt }| ,
and the expectation is w.r.t. both the (uniform) distribution
of it , and distribution D generating the items in Cit , conditioned on all past events. Since, by the Azuma-Hoeffding
inequality, Tht ,jt ,t‚àí1 concentrates as

To get a feeling of how big (or small) E[S] and var[S] can
be, let us consider the case where each partition over users
has a single big cluster and a number of small ones. To make
it clear, consider the extreme scenario where each P (eh ) has
one cluster of size vh,1 = n‚àö‚àí (m ‚àí 1), and m ‚àí 1 clusters
n. Then it is easy to see that
of size vp
h,j = 1, with m <
E[S] = n ‚àí (m ‚àí 1) + m ‚àí 1, and var(S) = 0, so that the
‚àö
e dT ), which is
resulting regret bound essentially becomes O(
the standard regret bound one achieves for learning a single
d-dimensional user (aka, the standard noncontextual bandit
bound with d actions and no gap assumptions among them).
At the other extreme lies the case when each partition P (eh )
has n-many clusters, so that
‚àö E[S] = n, var(S) = 0, and
e dnT ). Looser upper bounds can
the resulting bound is O(
be achieved in the case when var(S) > 0, where also the
interplay with c starts becoming relevant. Finally, observe
that the number g of distinct partitions influences the bound
only indirectly through var(S). Yet, it is worth repeating
here that g plays a crucial role in the computational (both
time and space) complexity of the whole procedure.

Tht ,jt ,t‚àí1 ‚âà
we have

Ô£Æ

t‚àí1
vht ,jt ,
n

Ô£π
X vh ,j
1
t
Ô£ª .
q
(1) ‚âà ED Ô£∞
n
1 + t‚àí1
v
j=1
h
,j
t
dn
mht

It is the latter expression that rules the cumulative regret of
COFIBA in that, up to log factors:
Ô£π
Ô£Æ
mht
T
T
X
X vh ,j
X
1
t
Ô£ª .
q
(2)
rt ‚âà
ED Ô£∞
n
t‚àí1
v
1+
t=1
t=1
j=1
dn

ht ,j

Eq. (2) is essentially (up to log factors and omitted additive terms) the regret bound one would obtain by knowning
beforehand the latent clustering structure over U.
Because ht ‚àà Cit is itself a function of the items in Cit , we
can eliminate the dependence on ht by the following simple
stratification argument. First of all, notice that
r
mht
mht
X vh ,j
1
d X‚àö
t
q
‚âà
vht ,j .
n
nt j=1
1 + t‚àí1 v
j=1

Proof of Theorem 1. The proof sketch builds on the
analysis in [1]. Let the true underlying clusters over the
users be Vh,1 , Vh,2 , . . . , Vh,mh , with |Vh,j | = vh,j . In [1], the
authors show that, because each user i has probability 1/n
to be the one served in round t, we have, with high probability, wi,t ‚Üí ui for all i, as t grows large. Moreover,
because of the gap assumption involving parameter Œ≥, all
edges connecting users belonging to different clusters at the
user side will eventually be deleted (again, with high probability), after each user i is served at least O( Œ≥12 ) times. By
the way edges are disconnected at the item side, the above
is essentially independent (up to log factors due to union
bounds) of which graph at the user side we are referring to.
In turn, this entails that the current user clusters encoded
by the connected components of graph GU
t,h will eventually
converge to the mh true user clusters (again, independent
of h, up to log factors), so that the aggregate weight vectors
wÃÑNk ,t‚àí1 computed by the algorithm for trading off exploration vs. exploitation in round t will essentially converge
to uit at a rate of the form10
"
#
1
E p
,
(1)
1 + Tht ,jt ,t‚àí1 /d

dn

ht ,j

P h ‚àö
Then, we set for brevity S(h) = m
vh,j , and let ht,k be
j=1
the index of the true cluster over items that xt,k belongs to
(recall that‚àöht,k is a random variable since so is xt,k ). Since
S(ht,k ) ‚â§ mn, a standard argument shows that


ED [S(ht )] ‚â§ ED
max S(ht,k )
k=1,...,ct
q ‚àö
‚â§ ED [S(ht,1 )] + c mn varD (S(ht,1 )) + 1 ,
so
PTthat, after some overapproximations, we conclude that
t=1 rt is upper bounded with high probability by
!

r
q ‚àö
d
T
e
O
ED [S(h)] + c mn varD (S(h)) + 1
,
n
the expectation and the variance being over the random index h such that eh ‚àº D.

7.

CONCLUSIONS

We have initiated an investigation of collaborative filtering bandit algorithms operating in relevant scenarios where
multiple users can be grouped by behavior similarity in different ways w.r.t. items and, in turn, the universe of items
can possibly be grouped by the similarity of clusterings they
induce over users. We carried out an extensive experimental comparison with very encouraging results, and have also
given a regret analysis which operates in a simplified scenario. Our algorithm can in principle be modified so as to
be combined with any standard clustering (or co-clustering)
technique. However, one advantage of encoding clusters as
connected components of graphs (at least at the user side) is

where ht is the index of the true cluster over items that xÃÑt
belongs to, jt is the index of the true cluster over users that
it belongs to (according to the partition of U determined
9
e
The O-notation
hides logarithmic factors in n, m, g, T , d,
1/Œ¥, as well as terms which are independent of T .
10
Because I = {e1 , . . . , ed }, the minimal eigenvalue Œª of the
process correlation matrix E[X X > ] in [1] is here 1/d. Moreover, compared to [1], we do not strive to capture the geometry of the user vectors
‚àö ui in the regret bound, hence we do
not have the extra m factor occurring in their bound.

547

that we are quite effective in tackling the so-called cold start
problem, for the newly served users are more likely to be
connected to the old ones, which makes COFIBA in a position to automatically propagate information from the old
users to the new ones through the aggregate vectors wÃÑNk ,t .
In fact, so far we have not seen any other way of adaptively
clustering users and items which is computationally affordable on sizeable datasets and, at the same time, amenable
to a regret analysis that takes advantage of the clustering
assumption.
All our experiments have been conducted in the setup of
one-hot encoding, since the datasets at our disposal did not
come with reliable/useful annotations on data. Yet, the algorithm we presented can clearly work when the items are
accompanied by (numerical) features. One direction of our
future research is to compensate for the lack of features in
the data by first inferring features during an initial training phase through standard matrix factorization techniques,
and subsequently applying our algorithm to a universe of
items I described through such inferred features. Another
line of experimental research would be to combine different
bandit algorithms (possibly at different stages of the learning process) so as to roughly get the best of all of them in
all stages. This would be somewhat similar to the metabandit construction described in [25]. Another one would
be to combine with matrix factorization techniques as in,
e.g., [20].

8.

[11] G. Cavallanti, N. Cesa-Bianchi, and C. Gentile. Tracking
the best hyperplane with a simple budget perceptron.
Machine Learning, 69/2:143‚Äì167, 2007.
[12] W. Chu, L. Li, L. Reyzin, and R. E. Schapire. Contextual
bandits with linear payoff functions. In AISTATS, 2011.
[13] K. Crammer and C. Gentile. Multiclass classification with
bandit feedback using adaptive regularization. In ICML,
2011.
[14] I. S. Dhillon. Co-clustering documents and words using
bipartite spectral graph partitioning. In 7th KDD, pages
269‚Äì274. ACM, 2001.
[15] I. S. Dhillon, S. Mallela, and D. S. Modha.
Information-theoretic co-clustering. In 9th KDD, pages
89‚Äì98, New York, NY, USA, 2003. ACM.
[16] J. Djolonga, A. Krause, and V. Cevher. High-dimensional
gaussian process bandits. In NIPS, pages 1025‚Äì1033, 2013.
[17] M. Dudik, D. Erhan, J. Langford, and L. Li.
Sample-efficient nonstationary-policy evaluation for
contextual bandits. In UAI, 2012.
[18] T. George and S. Merugu. A scalable collaborative filtering
framework based on co-clustering. In 5th ICDM, pages
625‚Äì628. IEEE Computer Society, 2005.
[19] F. Hao, S. Li, G. Min, H. Kim, S. Yau, and L. Yang, An
Efficient Approach to Generating Location-Sensitive
Recommendations in Ad-hoc Social Network Environments.
IEEE Transactions on Services Computing, 8:3, pp.
520‚Äì533, 2015.
[20] J. Kawale, H. Bui, B. Kveton, L. Thanh, and S. Chawla.
Efficient thompson sampling for online matrix-factorization
recommendation. In NIPS, 2015.
[21] A. Krause and C. Ong. Contextual gaussian process bandit
optimization. In 25th NIPS, 2011.
[22] B. Kveton, C. Szepesvari, Z. Wen, and A. Ashkan.
Cascading bandits: Learning to rank in the cascade model.
In ICML, 2015.
[23] L. Li, W. Chu, J. Langford, and R. Schapire. A
contextual-bandit approach to personalized news article
recommendation. In WWW, pages 661‚Äì670, 2010.
[24] S. Li, F. Hao, M. Li, and H.C. Kim. Medicine Rating
Prediction and Recommendation in Mobile Social
Networks. In International Conference on Green, Pervasive
and Cloud Computing, 2013.
[25] L. Tang, Y. Jiang, L. Li, and T. Li. Ensemble contextual
bandits for personalized recommendation. In RecSys, 2014.
[26] S. Li, C. Gentile, and A. Karatzoglou. Graph clustering
bandits for recommendation. arXiv:1605.00596.
[27] O. Maillard and S. Mannor. Latent bandits. In ICML, 2014.
[28] E. Moroshko, N. Vaits, and K. Crammer. Second-order
non-stationary online learning for regression. Journal of
Machine Learning Research, 16:1481‚Äì1517, 2015.
[29] T. T. Nguyen and H. W. Lauw. Dynamic clustering of
contextual multi-armed bandits. In 23rd CIKM, pages
1959‚Äì1962. ACM, 2014.
[30] Y. Seldin, P. Auer, F. Laviolette, J. Shawe-Taylor, and
R. Ortner. Pac-bayesian analysis of contextual bandits. In
NIPS, pages 1683‚Äì1691, 2011.
[31] I. Sutskever, R. Salakhutdinov, and J. Tenenbaum.
Modelling relational data using bayesian clustered tensor
factorization. In NIPS, pages 1821‚Äì1828. MIT Press, 2009.
[32] L. Tang, Y. Jiang, L. Li, C. Zeng, and T. Li. Personalized
recommendation via parameter-free contextual bandits. In
SIGIR. ACM, 2015.
[33] K. Verstrepen and B. Goethals. Unifying nearest neighbors
collaborative filtering. In RecSys, 2014.
[34] Y. Yue, S. A. Hong, and C. Guestrin. Hierarchical
exploration for accelerating contextual bandits. In ICML,
2012.

ACKNOWLEDGMENTS

We would like to thank the anonymous reviewers for their
helpful and constructive comments. The first author thanks
the support from MIUR and QCRI-HBKU. Also, the first
and the third author acknowledge the support from Amazon AWS Award in Machine Learning Research Grant. The
work leading to these results has received funding from the
European Union‚Äôs Seventh Framework Programme (FP7/
2007-2013) under CrowdRec Grant Agreement n‚ó¶ 610594.

9.

REFERENCES

[1] C. Gentile, S. Li, and G. Zappella. Online clustering of
bandits. In ICML, 2014.
[2] N. Korda, B. Szorenyi, and S. Li, Distributed Clustering of
Linear Bandits in Peer to Peer Networks. In ICML, 2016.
[3] Y. Abbasi-Yadkori, D. PaÃÅl, and C. SzepesvaÃÅri. Improved
algorithms for linear stochastic bandits. 2011.
[4] J.-Y. Audibert, R. Munos, and C. SzepesvaÃÅri.
Exploration-exploitation tradeoff using variance estimates
in multi-armed bandits. Theoretical Computer Science,
410(19):1876‚Äì1902, 2009.
[5] P. Auer. Using confidence bounds for
exploration-exploitation trade-offs. Journal of Machine
Learning Research, 3:397‚Äì422, 2002.
[6] P. Auer, N. Cesa-Bianchi, and P. Fischer. Finite-time
analysis of the multiarmed bandit problem. Machine
Learning, 2001.
[7] M. G. Azar, A. Lazaric, and E. Brunskill. Sequential
transfer in multi-armed bandit with finite set of models. In
NIPS, pages 2220‚Äì2228, 2013.
[8] G. Bresler, G. Chen, and S. D. A latent source model for
online collaborative filtering. In NIPS. MIT Press, 2014.
[9] E. Brunskill and L. Li. Sample complexity of multi-task
reinforcement learning. In UAI, 2013.
[10] W. Cao, J. Li, Y. Tao, and Z. Li. On top-k selection in
multi-armed bandits and hidden bipartite graphs. In NIPS,
2015.

548

